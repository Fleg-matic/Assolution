name: üè≠ Deploy Production

on:
    push:
        branches: [master]
    workflow_dispatch:

jobs:
    test-complete:
        name: üß™ Complete Test Suite
        runs-on: ubuntu-latest

        services:
            postgres:
                image: postgres:17
                env:
                    POSTGRES_DB: assolution_test
                    POSTGRES_USER: assolution_user
                    POSTGRES_PASSWORD: ${{ secrets.DB_PASSWORD }}
                options: >-
                    --health-cmd pg_isready
                    --health-interval 10s
                    --health-timeout 5s
                    --health-retries 5
                ports:
                    - 5432:5432

        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: ‚òï Setup Java 21
              uses: actions/setup-java@v4
              with:
                  java-version: "21"
                  distribution: "temurin"

            - name: üü¢ Setup Node.js 22
              uses: actions/setup-node@v4
              with:
                  node-version: "22"
                  cache: "npm"
                  cache-dependency-path: ./inscriptions/inscriptions-frontend/package-lock.json

            - name: üì¶ Cache Maven dependencies
              uses: actions/cache@v4
              with:
                  path: ~/.m2
                  key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}

            - name: üîß Backend Tests & Build
              working-directory: ./inscriptions/inscriptions-backend
              run: |
                  mvn clean test verify
                  mvn jacoco:report
                  mvn package -DskipTests

            - name: üîê Generate environment.prod.ts from template
              working-directory: ./inscriptions/inscriptions-frontend
              env:
                  # ‚úÖ Variables d'environnement pour le template
                  FRONTEND_API_URL: ${{ secrets.FRONTEND_API_URL }}
                  FRONTEND_BASE_URL: ${{ secrets.FRONTEND_BASE_URL }}
                  STRIPE_PUBLISHABLE_KEY_PROD: ${{ secrets.STRIPE_PUBLISHABLE_KEY_PROD }}
                  ENABLE_ANALYTICS: ${{ secrets.ENABLE_ANALYTICS }}
                  ENABLE_HTTPS_REDIRECT: ${{ secrets.ENABLE_HTTPS_REDIRECT }}
                  SUPPORT_EMAIL: ${{ secrets.SUPPORT_EMAIL }}
                  SALES_EMAIL: ${{ secrets.SALES_EMAIL }}
                  SUPPORT_PHONE: ${{ secrets.SUPPORT_PHONE }}
                  COOKIE_DOMAIN: ${{ secrets.COOKIE_DOMAIN }}
                  COOKIE_SECURE: ${{ secrets.COOKIE_SECURE }}
                  GOOGLE_ANALYTICS_ID: ${{ secrets.GOOGLE_ANALYTICS_ID }}
              run: |
                  echo "üîç Checking template existence..."
                  if [ ! -f "../../config-templates/environment.prod.ts.template" ]; then
                    echo "‚ùå Template not found!"
                    exit 1
                  fi

                  echo "üìù Generating environment.prod.ts from template..."
                  mkdir -p src/environments

                  # Utiliser envsubst pour substituer les variables
                  envsubst < ../../config-templates/environment.prod.ts.template > src/environments/environment.prod.ts

                  echo "‚úÖ Environment file generated:"
                  echo "üìä File size: $(wc -l < src/environments/environment.prod.ts) lines"
                  echo "üîç First 10 lines:"
                  head -10 src/environments/environment.prod.ts

                  # V√©rification de la syntaxe TypeScript
                  echo "üîç Checking TypeScript syntax..."
                  node -e "
                    const fs = require('fs');
                    const content = fs.readFileSync('src/environments/environment.prod.ts', 'utf8');
                    if (content.includes('undefined') || content.includes('\${')) {
                      console.error('‚ùå Variables not properly substituted!');
                      console.log('Content preview:', content.substring(0, 500));
                      process.exit(1);
                    }
                    console.log('‚úÖ File looks good');
                  "

            - name: üì¶ Frontend Tests & Build
              working-directory: ./inscriptions/inscriptions-frontend
              run: |
                  npm cache clean --force
                  rm -f package-lock.json
                  npm install
                  npm run test:ci
                  npm run build:prod

            - name: üìä SonarQube Analysis
              working-directory: ./inscriptions/inscriptions-backend
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                  SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
              run: |
                  mvn sonar:sonar \
                    -Dsonar.projectKey=assolution \
                    -Dsonar.organization=fleg-matic \
                    -Dsonar.host.url=https://sonarcloud.io \
                    -Dsonar.projectName="Assolution" \
                    -Dsonar.projectDescription="API REST Spring Boot pour la plateforme d'inscriptions" \
                    -Dsonar.links.homepage=https://github.com/${{ github.repository }} \
                    -Dsonar.links.ci=https://github.com/${{ github.repository }}/actions \
                    -Dsonar.links.scm=https://github.com/${{ github.repository }} \
                    -Dsonar.sources=src/main/java \
                    -Dsonar.tests=src/test/java \
                    -Dsonar.java.binaries=target/classes \
                    -Dsonar.java.test.binaries=target/test-classes \
                    -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml \
                    -Dsonar.junit.reportPaths=target/surefire-reports

            - name: üîß Setup E2E environment and Cypress
              env:
                  # Variables pour les tests E2E
                  CYPRESS_BASE_URL: ${{ secrets.CYPRESS_BASE_URL_PROD }}
                  CYPRESS_API_URL: ${{ secrets.CYPRESS_API_URL_PROD }}
                  CYPRESS_ENVIRONMENT: ${{ secrets.CYPRESS_ENVIRONMENT_PROD }}
                  CYPRESS_TEST_USER_EMAIL: ${{ secrets.CYPRESS_TEST_USER_EMAIL }}
                  CYPRESS_TEST_USER_PASSWORD: ${{ secrets.CYPRESS_TEST_USER_PASSWORD }}
                  CYPRESS_TEST_ADMIN_EMAIL: ${{ secrets.CYPRESS_TEST_ADMIN_EMAIL }}
                  CYPRESS_TEST_ADMIN_PASSWORD: ${{ secrets.CYPRESS_TEST_ADMIN_PASSWORD }}
              run: |
                  echo "üîß Setting up Cypress environment..."

                  # Installer Cypress
                  npm install cypress --save-dev
                  npx cypress verify

                  # Utiliser le cypress.config.js existant (il g√®re d√©j√† les variables d'environnement)
                  echo "‚úÖ Cypress configured with existing config file"
                  echo "üåê Base URL: $CYPRESS_BASE_URL"
                  echo "üîå API URL: $CYPRESS_API_URL"

            - name: üî¨ E2E Tests
              env:
                  # Variables d'environnement pour Docker Compose E2E
                  DB_PASSWORD_PROD: ${{ secrets.DB_PASSWORD_PROD }}
                  JWT_SECRET_PROD: ${{ secrets.JWT_SECRET_PROD }}
                  STRIPE_SECRET_KEY_PROD: ${{ secrets.STRIPE_SECRET_KEY_PROD }}
                  STRIPE_WEBHOOK_SECRET_PROD: ${{ secrets.STRIPE_WEBHOOK_SECRET_PROD }}
                  EMAIL_HOST_PROD: ${{ secrets.EMAIL_HOST_PROD }}
                  EMAIL_USER_PROD: ${{ secrets.EMAIL_USER_PROD }}
                  EMAIL_PASSWORD_PROD: ${{ secrets.EMAIL_PASSWORD_PROD }}
                  FRONTEND_API_URL: ${{ secrets.FRONTEND_API_URL }}
                  FRONTEND_BASE_URL: ${{ secrets.FRONTEND_BASE_URL }}
                  STRIPE_PUBLISHABLE_KEY_PROD: ${{ secrets.STRIPE_PUBLISHABLE_KEY_PROD }}
                  ENABLE_ANALYTICS: ${{ secrets.ENABLE_ANALYTICS }}
                  ENABLE_HTTPS_REDIRECT: ${{ secrets.ENABLE_HTTPS_REDIRECT }}
                  SUPPORT_EMAIL: ${{ secrets.SUPPORT_EMAIL }}
                  SALES_EMAIL: ${{ secrets.SALES_EMAIL }}
                  SUPPORT_PHONE: ${{ secrets.SUPPORT_PHONE }}
                  COOKIE_DOMAIN: ${{ secrets.COOKIE_DOMAIN }}
                  COOKIE_SECURE: ${{ secrets.COOKIE_SECURE }}
                  GOOGLE_ANALYTICS_ID: ${{ secrets.GOOGLE_ANALYTICS_ID }}
                  # Variables Cypress
                  CYPRESS_BASE_URL: ${{ secrets.CYPRESS_BASE_URL_PROD }}
                  CYPRESS_API_URL: ${{ secrets.CYPRESS_API_URL_PROD }}
                  CYPRESS_ENVIRONMENT: ${{ secrets.CYPRESS_ENVIRONMENT_PROD }}
                  CYPRESS_TEST_USER_EMAIL: ${{ secrets.CYPRESS_TEST_USER_EMAIL }}
                  CYPRESS_TEST_USER_PASSWORD: ${{ secrets.CYPRESS_TEST_USER_PASSWORD }}
                  CYPRESS_TEST_ADMIN_EMAIL: ${{ secrets.CYPRESS_TEST_ADMIN_EMAIL }}
                  CYPRESS_TEST_ADMIN_PASSWORD: ${{ secrets.CYPRESS_TEST_ADMIN_PASSWORD }}
              run: |
                  echo "üöÄ Starting E2E test environment..."

                  # Nettoyer les containers existants
                  docker compose -f docker-compose.prod.yml down --remove-orphans || true
                  docker system prune -f || true

                  # V√©rifier que les ports sont libres
                  sudo lsof -ti:5432 | xargs -r sudo kill -9 || true
                  sudo lsof -ti:8080 | xargs -r sudo kill -9 || true

                  # D√©marrer les services
                  echo "üîÑ Starting services with docker-compose.prod.yml..."
                  docker compose -f docker-compose.prod.yml up -d --build

                  # Attendre que les services soient pr√™ts
                  echo "‚è≥ Waiting for services to be ready..."
                  sleep 60

                  # Diagnostic des services
                  echo "üìã Container status:"
                  docker compose -f docker-compose.prod.yml ps

                  echo "üìã Backend logs:"
                  docker compose -f docker-compose.prod.yml logs backend --tail=20

                  echo "üìã Frontend builder logs:"
                  docker compose -f docker-compose.prod.yml logs frontend-builder --tail=20

                  echo "üìã Nginx logs:"
                  docker compose -f docker-compose.prod.yml logs nginx --tail=20

                  # Tests de connectivit√© progressifs
                  echo "üîç Testing services health..."

                  # Test PostgreSQL
                  timeout 30 bash -c 'until docker compose -f docker-compose.prod.yml exec -T postgres pg_isready -U assolution_user -d assolution_prod; do echo "Waiting for PostgreSQL..."; sleep 5; done' || echo "‚ùå PostgreSQL not ready"

                  # Test Backend
                  timeout 120 bash -c 'until curl -f http://localhost:8080/api/actuator/health; do echo "Waiting for backend..."; sleep 5; done' || echo "‚ùå Backend not ready"

                  # Test Nginx
                  timeout 60 bash -c 'until curl -f http://localhost:80/; do echo "Waiting for nginx..."; sleep 5; done' || echo "‚ùå Nginx not ready"

                  # Si tous les services sont pr√™ts, lancer Cypress
                  if curl -f http://localhost:80/ && curl -f http://localhost:8080/api/actuator/health; then
                    echo "‚úÖ All services ready, starting Cypress tests..."
                    npx cypress run --spec "cypress/e2e/**/*.cy.js" --browser chrome --headless
                  else
                    echo "‚ùå Services not ready, skipping Cypress tests"
                    echo "üìã Final diagnostics:"
                    docker compose -f docker-compose.prod.yml logs --tail=50
                    exit 1
                  fi

                  # Nettoyer apr√®s les tests
                  docker compose -f docker-compose.prod.yml down

    security-scan:
        name: üîí Security Scan
        runs-on: ubuntu-latest
        needs: [test-complete]

        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: üîç Run Trivy vulnerability scanner
              uses: aquasecurity/trivy-action@master
              with:
                  scan-type: "fs"
                  scan-ref: "."
                  format: "sarif"
                  output: "trivy-results.sarif"

            - name: üì§ Upload Trivy scan results to GitHub Security tab
              uses: github/codeql-action/upload-sarif@v3
              if: always()
              with:
                  sarif_file: "trivy-results.sarif"

    deploy-prod:
        name: üöÄ Deploy to Production
        runs-on: ubuntu-latest
        needs: [test-complete, security-scan]
        environment: production

        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: üîë Setup SSH
              uses: webfactory/ssh-agent@v0.9.0
              with:
                  ssh-private-key: ${{ secrets.SSH_KEY }}

            - name: üíæ Backup Production Database
              run: |
                  ssh -o StrictHostKeyChecking=no ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "
                    cd /home/dbm/assolution-prod || exit 0
                    
                    if docker compose ps | grep postgres; then
                      timestamp=\$(date +%Y%m%d_%H%M%S)
                      mkdir -p backups
                      docker compose exec -T postgres pg_dump -U assolution_user assolution_prod > backups/backup_\${timestamp}.sql
                      echo 'üíæ Database backup created: backup_\${timestamp}.sql'
                    fi
                  "

            - name: üìÇ Deploy to Production VM
              env:
                  # ‚úÖ TOUTES les variables d'environnement pour la production
                  DB_PASSWORD: ${{ secrets.DB_PASSWORD_PROD }}
                  DB_NAME: "assolution_prod"
                  DB_USER: "assolution_user"
                  JWT_SECRET: ${{ secrets.JWT_SECRET_PROD }}
                  STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY_PROD }}
                  STRIPE_WEBHOOK_SECRET: ${{ secrets.STRIPE_WEBHOOK_SECRET_PROD }}
                  STRIPE_PUBLISHABLE_KEY_PROD: ${{ secrets.STRIPE_PUBLISHABLE_KEY_PROD }}
                  EMAIL_HOST: ${{ secrets.EMAIL_HOST_PROD }}
                  EMAIL_USER: ${{ secrets.EMAIL_USER_PROD }}
                  EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD_PROD }}
                  EMAIL_BASE_URL: ${{ secrets.EMAIL_BASE_URL }}
                  FRONTEND_API_URL: ${{ secrets.FRONTEND_API_URL }}
                  FRONTEND_BASE_URL: ${{ secrets.FRONTEND_BASE_URL }}
                  BACKEND_URL_PROD: ${{ secrets.BACKEND_URL_PROD }}
                  COOKIE_DOMAIN: ${{ secrets.COOKIE_DOMAIN }}
                  COOKIE_SECURE: ${{ secrets.COOKIE_SECURE }}
                  CORS_ALLOWED_ORIGINS: ${{ secrets.CORS_ALLOWED_ORIGINS }}
                  ENABLE_ANALYTICS: ${{ secrets.ENABLE_ANALYTICS }}
                  ENABLE_HTTPS_REDIRECT: ${{ secrets.ENABLE_HTTPS_REDIRECT }}
                  SUPPORT_EMAIL: ${{ secrets.SUPPORT_EMAIL }}
                  SALES_EMAIL: ${{ secrets.SALES_EMAIL }}
                  SUPPORT_PHONE: ${{ secrets.SUPPORT_PHONE }}
                  GOOGLE_ANALYTICS_ID: ${{ secrets.GOOGLE_ANALYTICS_ID }}
              run: |
                  # Cr√©er le dossier de production
                  ssh -o StrictHostKeyChecking=no ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "
                    mkdir -p /home/dbm/assolution-prod
                    sudo systemctl is-active docker || sudo systemctl start docker
                  "

                  # Copier les fichiers
                  scp -o StrictHostKeyChecking=no -r ./* ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/home/dbm/assolution-prod/

                  # D√©ploiement en production
                  ssh -o StrictHostKeyChecking=no ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "
                    cd /home/dbm/assolution-prod
                    
                    echo 'üöÄ Starting production deployment...'
                    docker compose -f docker-compose.prod.yml down --remove-orphans
                    docker compose -f docker-compose.prod.yml build --no-cache
                    docker compose -f docker-compose.prod.yml up -d
                    
                    echo '‚è≥ Waiting for services to start...'
                    sleep 60
                    
                    # Diagnostic
                    echo 'üìä Container status:'
                    docker compose -f docker-compose.prod.yml ps
                    echo 'üìã Recent logs:'
                    docker compose -f docker-compose.prod.yml logs --tail=20
                    
                    # Nettoyer les anciennes images
                    docker image prune -f
                  "

            - name: ü©∫ Production Health Checks
              run: |
                  sleep 90

                  echo "üîç Running comprehensive health checks..."

                  # Test API Health
                  for i in {1..15}; do
                    if curl -f http://${{ secrets.SSH_HOST }}/api/actuator/health; then
                      echo "‚úÖ API health check passed"
                      break
                    fi
                    echo "‚è≥ Waiting for API... (attempt $i/15)"
                    sleep 10
                    if [ $i -eq 15 ]; then
                      echo "‚ùå API health check failed after 15 attempts"
                      exit 1
                    fi
                  done

                  # Test Frontend
                  if curl -f http://${{ secrets.SSH_HOST }}/; then
                    echo "‚úÖ Frontend is accessible"
                  else
                    echo "‚ùå Frontend accessibility check failed"
                    exit 1
                  fi

            - name: üì¢ Production Deployment Notification
              if: success()
              run: |
                  echo "üéâ Production deployment successful!"
                  echo "üîó Production URL: http://${{ secrets.SSH_HOST }}"
                  echo "üîó API URL: http://${{ secrets.SSH_HOST }}/api"
                  echo "üìä Health Check: http://${{ secrets.SSH_HOST }}/api/actuator/health"

            - name: üö® Rollback on Failure
              if: failure()
              run: |
                  echo "‚ùå Deployment failed, attempting rollback..."
                  ssh -o StrictHostKeyChecking=no ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "
                    cd /home/dbm/assolution-prod
                    docker compose -f docker-compose.prod.yml down
                    docker compose -f docker-compose.prod.yml up -d
                    echo 'üîÑ Rollback completed'
                  "
                  exit 1
