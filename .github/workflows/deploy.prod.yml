deploy-prod:
    name: 🚀 Deploy to Production
    runs-on: self-hosted
    needs: [test-complete, security-scan]
    environment: production

    steps:
        - name: 📥 Checkout code
          uses: actions/checkout@v4
          with:
              fetch-depth: 0

        - name: 🧪 Test Environment Variables DEBUG
              env:
                DB_PASSWORD_PROD: ${{ secrets.DB_PASSWORD_PROD }}
                JWT_SECRET_PROD: ${{ secrets.JWT_SECRET_PROD }}
                ADMIN_PASSWORD_PROD: ${{ secrets.ADMIN_PASSWORD_PROD }}
                EMAIL_HOST_PROD: ${{ secrets.EMAIL_HOST_PROD }}
              run: |
                echo "🔍 Testing environment variables:"
                echo "DB_PASSWORD_PROD: ${DB_PASSWORD_PROD:+PRESENT ($(echo $DB_PASSWORD_PROD | wc -c) chars)}"
                echo "JWT_SECRET_PROD: ${JWT_SECRET_PROD:+PRESENT}"
                echo "ADMIN_PASSWORD_PROD: ${ADMIN_PASSWORD_PROD:+PRESENT}"
                echo "EMAIL_HOST_PROD: ${EMAIL_HOST_PROD:+PRESENT}"
                
                echo ""
                echo "🔍 Complete environment check:"
                echo "Total environment variables: $(env | wc -l)"
                echo "GitHub-related vars:"
                env | grep -E "^(GITHUB_|RUNNER_)" | head -5
                
                echo ""
                if [ -z "$DB_PASSWORD_PROD" ]; then
                  echo "❌ DB_PASSWORD_PROD is empty!"
                  echo "Available secrets starting with DB_:"
                  env | grep "DB_" || echo "No DB_ vars found"
                  echo "Available secrets:"
                  env | grep -E "(SECRET|PASSWORD|TOKEN)" | cut -d= -f1 | head -10
                  exit 1
                else
                  echo "✅ DB_PASSWORD_PROD is properly set with $(echo $DB_PASSWORD_PROD | wc -c) characters"
                fi

        - name: 🔍 System Info
          run: |
              echo "🖥️ Running on local VM:"
              hostname
              whoami
              pwd
              ip addr show | grep inet
              docker --version

        - name: 💾 Backup Production Database
          env:
              DB_PASSWORD_PROD: ${{ secrets.DB_PASSWORD_PROD }}
          run: |
              cd /home/dbm/assolution-prod || {
                echo "⚠️ Production directory not found, creating it..."
                mkdir -p /home/dbm/assolution-prod
                exit 0
              }

              if docker compose ps | grep postgres; then
                timestamp=$(date +%Y%m%d_%H%M%S)
                mkdir -p backups
                docker compose exec -T postgres pg_dump -U assolution_user assolution_prod > backups/backup_${timestamp}.sql
                echo "💾 Database backup created: backup_${timestamp}.sql"
              else
                echo "ℹ️ No existing PostgreSQL container found"
              fi

        - name: 📂 Deploy to Local Production
          env:
              # ✅ EXPLICITEMENT TOUTES les variables d'environnement pour la production
              DB_PASSWORD_PROD: ${{ secrets.DB_PASSWORD_PROD }}
              JWT_SECRET_PROD: ${{ secrets.JWT_SECRET_PROD }}
              STRIPE_SECRET_KEY_PROD: ${{ secrets.STRIPE_SECRET_KEY_PROD }}
              STRIPE_WEBHOOK_SECRET_PROD: ${{ secrets.STRIPE_WEBHOOK_SECRET_PROD }}
              STRIPE_PUBLISHABLE_KEY_PROD: ${{ secrets.STRIPE_PUBLISHABLE_KEY_PROD }}
              EMAIL_HOST_PROD: ${{ secrets.EMAIL_HOST_PROD }}
              EMAIL_USER_PROD: ${{ secrets.EMAIL_USER_PROD }}
              EMAIL_PASSWORD_PROD: ${{ secrets.EMAIL_PASSWORD_PROD }}
              EMAIL_BASE_URL: ${{ secrets.EMAIL_BASE_URL }}
              CORS_ALLOWED_ORIGINS: ${{ secrets.CORS_ALLOWED_ORIGINS }}
              FRONTEND_API_URL: ${{ secrets.FRONTEND_API_URL }}
              FRONTEND_BASE_URL: ${{ secrets.FRONTEND_BASE_URL }}
              BACKEND_URL_PROD: ${{ secrets.BACKEND_URL_PROD }}
              COOKIE_DOMAIN: ${{ secrets.COOKIE_DOMAIN }}
              COOKIE_SECURE: ${{ secrets.COOKIE_SECURE }}
              ENABLE_ANALYTICS: ${{ secrets.ENABLE_ANALYTICS }}
              ENABLE_HTTPS_REDIRECT: ${{ secrets.ENABLE_HTTPS_REDIRECT }}
              SUPPORT_EMAIL: ${{ secrets.SUPPORT_EMAIL }}
              SALES_EMAIL: ${{ secrets.SALES_EMAIL }}
              SUPPORT_PHONE: ${{ secrets.SUPPORT_PHONE }}
              GOOGLE_ANALYTICS_ID: ${{ secrets.GOOGLE_ANALYTICS_ID }}
              ADMIN_PASSWORD_PROD: ${{ secrets.ADMIN_PASSWORD_PROD }}
          run: |
              echo "🚀 Starting local production deployment..."

              # ✅ DEBUG : Vérifier les variables avant de commencer
              echo "🔍 Checking critical environment variables:"
              echo "DB_PASSWORD_PROD: ${DB_PASSWORD_PROD:+SET}" 
              echo "JWT_SECRET_PROD: ${JWT_SECRET_PROD:+SET}"
              echo "ADMIN_PASSWORD_PROD: ${ADMIN_PASSWORD_PROD:+SET}"

              if [ -z "$DB_PASSWORD_PROD" ]; then
                echo "❌ CRITICAL: DB_PASSWORD_PROD is not set!"
                echo "Available env vars:"
                env | grep -E "(DB_|JWT_|ADMIN_)" || echo "No matching vars found"
                exit 1
              fi

              # Créer le dossier de production s'il n'existe pas
              mkdir -p /home/dbm/assolution-prod

              # Copier les fichiers du workspace vers le dossier de production
              echo "📁 Copying files to production directory..."
              rsync -av --exclude='.git' --exclude='node_modules' --exclude='target' \
                ${{ github.workspace }}/ /home/dbm/assolution-prod/

              # Changer vers le dossier de production
              cd /home/dbm/assolution-prod

              echo "🛑 Stopping existing services..."
              docker compose -f docker-compose.prod.yml down --remove-orphans || true

              echo "🗂️ Building services..."
              docker compose -f docker-compose.prod.yml build --no-cache

              echo "🚀 Starting services..."
              docker compose -f docker-compose.prod.yml up -d

              echo "⏳ Waiting for services to start..."
              sleep 60

              # Diagnostic
              echo "📊 Container status:"
              docker compose -f docker-compose.prod.yml ps
              echo "📋 Recent logs:"
              docker compose -f docker-compose.prod.yml logs --tail=20

              # Nettoyer les anciennes images
              docker image prune -f

        - name: 🩺 Production Health Checks
          env:
              DB_PASSWORD_PROD: ${{ secrets.DB_PASSWORD_PROD }}
              ADMIN_PASSWORD_PROD: ${{ secrets.ADMIN_PASSWORD_PROD }}
          run: |
              sleep 30

              echo "🔍 Running comprehensive health checks..."

              # ✅ Test API Health OPTIMISÉ - tentatives plus rapides
              for i in {1..10}; do
                if curl -f --max-time 10 http://localhost:8080/actuator/health; then
                  echo "✅ API health check passed in $i attempts"
                  break
                fi
                echo "⏳ Waiting for API... (attempt $i/10)"
                sleep 5
                if [ $i -eq 10 ]; then
                  echo "❌ API health check failed after 10 attempts"
                  echo "📋 Backend logs:"
                  cd /home/dbm/assolution-prod
                  docker compose -f docker-compose.prod.yml logs backend --tail=50
                  echo "📊 Container status:"
                  docker compose -f docker-compose.prod.yml ps
                  echo "🔍 System resources:"
                  docker stats --no-stream
                  exit 1
                fi
              done

              # ✅ Test plus détaillé de l'API avec timeout
              echo "🔍 Testing API endpoints..."

              # Test health avec détails et timeout
              health_response=$(curl -s --max-time 5 http://localhost:8080/actuator/health)
              echo "📊 Health response: $health_response"

              # Vérifier que la réponse contient "UP"
              if echo "$health_response" | grep -q '"status":"UP"'; then
                echo "✅ API status is UP"
                
                # Test des métriques si disponibles
                if curl -f --max-time 5 http://localhost:8080/actuator/info >/dev/null 2>&1; then
                  echo "✅ API info endpoint accessible"
                fi
              else
                echo "❌ API status is not UP"
                echo "📋 Full health response: $health_response"
                exit 1
              fi

              # Test Frontend
              if curl -f http://localhost:80/; then
                echo "✅ Frontend is accessible"
              elif curl -f http://localhost:4200/; then
                echo "✅ Frontend is accessible on port 4200"
              else
                echo "❌ Frontend accessibility check failed"
                echo "📋 Frontend/Nginx logs:"
                cd /home/dbm/assolution-prod
                docker compose -f docker-compose.prod.yml logs nginx --tail=20
                exit 1
              fi

        - name: 📢 Production Deployment Notification
          if: success()
          run: |
              echo "🎉 Production deployment successful!"
              echo "🔗 Production URL: http://192.168.1.22"
              echo "🔗 API URL: http://192.168.1.22/api"
              echo "📊 Health Check: http://192.168.1.22/api/actuator/health"

              # Afficher les informations système
              echo "🖥️ System Resources:"
              df -h /
              free -h
              docker system df

        - name: 🚨 Rollback on Failure
          if: failure()
          env:
              DB_PASSWORD_PROD: ${{ secrets.DB_PASSWORD_PROD }}
          run: |
              echo "❌ Deployment failed, attempting rollback..."
              cd /home/dbm/assolution-prod

              # Sauvegarder les logs de l'échec
              timestamp=$(date +%Y%m%d_%H%M%S)
              mkdir -p logs
              docker compose -f docker-compose.prod.yml logs > logs/failed_deployment_${timestamp}.log

              # Redémarrer les services
              docker compose -f docker-compose.prod.yml down
              docker compose -f docker-compose.prod.yml up -d
              echo "🔄 Rollback completed"

              # Vérifier que le rollback fonctionne
              sleep 30
              if curl -f http://localhost:80/ || curl -f http://localhost:4200/; then
                echo "✅ Rollback successful - application is running"
              else
                echo "❌ Rollback failed - manual intervention required"
              fi

              exit 1
