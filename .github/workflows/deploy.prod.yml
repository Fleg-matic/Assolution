name: üè≠ Deploy Production

on:
    push:
        branches: [master]
    workflow_dispatch:

jobs:
    test-complete:
        name: üß™ Complete Test Suite
        runs-on: ubuntu-latest

        services:
            postgres:
                image: postgres:17
                env:
                    POSTGRES_DB: assolution_test
                    POSTGRES_USER: assolution_user
                    POSTGRES_PASSWORD: ${{ secrets.DB_PASSWORD }}
                options: >-
                    --health-cmd pg_isready
                    --health-interval 10s
                    --health-timeout 5s
                    --health-retries 5
                ports:
                    - 5432:5432

        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: ‚òï Setup Java 21
              uses: actions/setup-java@v4
              with:
                  java-version: "21"
                  distribution: "temurin"

            - name: üü¢ Setup Node.js 22
              uses: actions/setup-node@v4
              with:
                  node-version: "22"
                  cache: "npm"
                  cache-dependency-path: ./inscriptions/inscriptions-frontend/package-lock.json

            - name: üì¶ Cache Maven dependencies
              uses: actions/cache@v4
              with:
                  path: ~/.m2
                  key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}

            - name: üîß Backend Tests & Build
              working-directory: ./inscriptions/inscriptions-backend
              run: |
                  mvn clean test verify
                  mvn jacoco:report
                  mvn package -DskipTests

            - name: üîê Generate environment.prod.ts from template
              working-directory: ./inscriptions/inscriptions-frontend
              env:
                  # ‚úÖ Variables d'environnement disponibles pour envsubst
                  FRONTEND_API_URL: ${{ secrets.FRONTEND_API_URL || '/api' }}
                  FRONTEND_BASE_URL: ${{ secrets.FRONTEND_BASE_URL || '' }}
                  STRIPE_PUBLISHABLE_KEY_PROD: ${{ secrets.STRIPE_PUBLISHABLE_KEY_PROD || 'pk_test_placeholder' }}
                  ENABLE_ANALYTICS: ${{ secrets.ENABLE_ANALYTICS || 'false' }}
                  ENABLE_HTTPS_REDIRECT: ${{ secrets.ENABLE_HTTPS_REDIRECT || 'false' }}
                  SUPPORT_EMAIL: ${{ secrets.SUPPORT_EMAIL || 'support@assolution.com' }}
                  SALES_EMAIL: ${{ secrets.SALES_EMAIL || 'contact@assolution.com' }}
                  SUPPORT_PHONE: ${{ secrets.SUPPORT_PHONE || '+33 1 XX XX XX XX' }}
                  COOKIE_DOMAIN: ${{ secrets.COOKIE_DOMAIN || 'localhost' }}
                  COOKIE_SECURE: ${{ secrets.COOKIE_SECURE || 'false' }}
                  GOOGLE_ANALYTICS_ID: ${{ secrets.GOOGLE_ANALYTICS_ID || '' }}
              run: |
                  echo "üîç Checking template existence..."
                  if [ ! -f "../../config-templates/environment.prod.ts.template" ]; then
                    echo "‚ùå Template not found!"
                    exit 1
                  fi

                  echo "üîç Debug: Environment variables:"
                  echo "FRONTEND_API_URL: $FRONTEND_API_URL"
                  echo "ENABLE_ANALYTICS: $ENABLE_ANALYTICS"
                  echo "COOKIE_SECURE: $COOKIE_SECURE"
                  echo "STRIPE_PUBLISHABLE_KEY_PROD: ${STRIPE_PUBLISHABLE_KEY_PROD:0:20}..." # Masquer la cl√©

                  echo "üìù Generating environment.prod.ts from template..."
                  mkdir -p src/environments

                  # Utiliser envsubst pour substituer les variables
                  envsubst < ../../config-templates/environment.prod.ts.template > src/environments/environment.prod.ts

                  echo "‚úÖ Environment file generated:"
                  echo "üìä File size: $(wc -l < src/environments/environment.prod.ts) lines"
                  echo "üîç First 10 lines:"
                  head -10 src/environments/environment.prod.ts

                  # V√©rification critique des substitutions
                  echo "üîç Checking TypeScript syntax..."
                  if grep -q '\${' src/environments/environment.prod.ts; then
                    echo "‚ùå Variables not properly substituted!"
                    echo "üîç Unsubstituted variables:"
                    grep -o '\${[^}]*}' src/environments/environment.prod.ts | sort | uniq
                    echo "Content preview:"
                    head -20 src/environments/environment.prod.ts
                    exit 1
                  fi

                  # V√©rification de syntaxe TypeScript
                  node -e "
                    const fs = require('fs');
                    const content = fs.readFileSync('src/environments/environment.prod.ts', 'utf8');
                    
                    // V√©rifier qu'il n'y a pas de valeurs vides probl√©matiques
                    if (content.includes(': ,') || content.includes(': undefined')) {
                      console.error('‚ùå Empty values detected!');
                      process.exit(1);
                    }
                    
                    console.log('‚úÖ File looks good');
                  "

                  echo "‚úÖ Environment.prod.ts ready for build"

            - name: üì¶ Frontend Tests & Build
              working-directory: ./inscriptions/inscriptions-frontend
              run: |
                  echo "üîß Fixing TypeScript version conflicts..."
                  npm cache clean --force
                  rm -rf node_modules package-lock.json

                  # Installation avec versions exactes compatibles
                  npm install
                  npm install --save-dev --save-exact typescript@5.8.3
                  npm install --save-dev --save-exact @angular/cli@20.1.5
                  npm install --save-dev --save-exact @angular-devkit/build-angular@20.1.5
                  npm install --save-dev --save-exact @angular/compiler-cli@20.1.6

                  echo "üìä Versions install√©es:"
                  echo "TypeScript: $(npx tsc --version)"
                  echo "Angular CLI: $(npx ng version --skip-git | grep "Angular CLI" || echo "CLI OK")"

                  npm run test:ci
                  npm run build:prod

            - name: üìä SonarQube Analysis
              working-directory: ./inscriptions/inscriptions-backend
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                  SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
              run: |
                  mvn sonar:sonar \
                    -Dsonar.projectKey=assolution \
                    -Dsonar.organization=fleg-matic \
                    -Dsonar.host.url=https://sonarcloud.io \
                    -Dsonar.projectName="Assolution" \
                    -Dsonar.projectDescription="API REST Spring Boot pour la plateforme d'inscriptions" \
                    -Dsonar.links.homepage=https://github.com/${{ github.repository }} \
                    -Dsonar.links.ci=https://github.com/${{ github.repository }}/actions \
                    -Dsonar.links.scm=https://github.com/${{ github.repository }} \
                    -Dsonar.sources=src/main/java \
                    -Dsonar.tests=src/test/java \
                    -Dsonar.java.binaries=target/classes \
                    -Dsonar.java.test.binaries=target/test-classes \
                    -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml \
                    -Dsonar.junit.reportPaths=target/surefire-reports

            - name: üîç Debug Environment Variables
              run: |
                  echo "üîç Checking environment variables availability..."
                  echo "FRONTEND_API_URL: '${{ secrets.FRONTEND_API_URL }}'"
                  echo "FRONTEND_BASE_URL: '${{ secrets.FRONTEND_BASE_URL }}'"
                  echo "STRIPE_PUBLISHABLE_KEY_PROD: '${{ secrets.STRIPE_PUBLISHABLE_KEY_PROD }}'"
                  echo "ENABLE_ANALYTICS: '${{ secrets.ENABLE_ANALYTICS }}'"
                  echo "ENABLE_HTTPS_REDIRECT: '${{ secrets.ENABLE_HTTPS_REDIRECT }}'"
                  echo "SUPPORT_EMAIL: '${{ secrets.SUPPORT_EMAIL }}'"
                  echo "SALES_EMAIL: '${{ secrets.SALES_EMAIL }}'"
                  echo "SUPPORT_PHONE: '${{ secrets.SUPPORT_PHONE }}'"
                  echo "COOKIE_DOMAIN: '${{ secrets.COOKIE_DOMAIN }}'"
                  echo "COOKIE_SECURE: '${{ secrets.COOKIE_SECURE }}'"
                  echo "GOOGLE_ANALYTICS_ID: '${{ secrets.GOOGLE_ANALYTICS_ID }}'"

                  echo ""
                  echo "üîç Checking if variables are properly set..."
                  if [ -z "${{ secrets.FRONTEND_API_URL }}" ]; then
                    echo "‚ùå FRONTEND_API_URL is not set in GitHub secrets"
                  else
                    echo "‚úÖ FRONTEND_API_URL is set"
                  fi

                  if [ -z "${{ secrets.ENABLE_ANALYTICS }}" ]; then
                    echo "‚ùå ENABLE_ANALYTICS is not set in GitHub secrets"
                  else
                    echo "‚úÖ ENABLE_ANALYTICS is set"
                  fi

            - name: üîß Setup E2E environment and Cypress
              env:
                  # Variables pour les tests E2E
                  CYPRESS_BASE_URL: ${{ secrets.CYPRESS_BASE_URL_PROD }}
                  CYPRESS_API_URL: ${{ secrets.CYPRESS_API_URL_PROD }}
                  CYPRESS_ENVIRONMENT: ${{ secrets.CYPRESS_ENVIRONMENT_PROD }}
                  CYPRESS_TEST_USER_EMAIL: ${{ secrets.CYPRESS_TEST_USER_EMAIL }}
                  CYPRESS_TEST_USER_PASSWORD: ${{ secrets.CYPRESS_TEST_USER_PASSWORD }}
                  CYPRESS_TEST_ADMIN_EMAIL: ${{ secrets.CYPRESS_TEST_ADMIN_EMAIL }}
                  CYPRESS_TEST_ADMIN_PASSWORD: ${{ secrets.CYPRESS_TEST_ADMIN_PASSWORD }}
              run: |
                  echo "üîß Setting up Cypress environment..."

                  # Installer Cypress
                  npm install cypress --save-dev
                  npx cypress verify

                  # Utiliser le cypress.config.js existant (il g√®re d√©j√† les variables d'environnement)
                  echo "‚úÖ Cypress configured with existing config file"
                  echo "üåê Base URL: $CYPRESS_BASE_URL"
                  echo "üîå API URL: $CYPRESS_API_URL"

            - name: üîç Debug Database Variables
              env:
                  DB_PASSWORD_PROD: ${{ secrets.DB_PASSWORD_PROD }}
                  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
                  JWT_SECRET_PROD: ${{ secrets.JWT_SECRET_PROD }}
              run: |
                  echo "üîç Checking database environment variables..."

                  if [ -z "$DB_PASSWORD_PROD" ] && [ -z "$DB_PASSWORD" ]; then
                    echo "‚ùå No database password found in secrets!"
                    echo "üí° Please set either DB_PASSWORD_PROD or DB_PASSWORD in GitHub secrets"
                    exit 1
                  fi

                  if [ -n "$DB_PASSWORD_PROD" ]; then
                    echo "‚úÖ DB_PASSWORD_PROD is set (length: ${#DB_PASSWORD_PROD})"
                  fi

                  if [ -n "$DB_PASSWORD" ]; then
                    echo "‚úÖ DB_PASSWORD is set (length: ${#DB_PASSWORD})"
                  fi

                  if [ -z "$JWT_SECRET_PROD" ]; then
                    echo "‚ö†Ô∏è JWT_SECRET_PROD is not set"
                  else
                    echo "‚úÖ JWT_SECRET_PROD is set (length: ${#JWT_SECRET_PROD})"
                  fi

            - name: üî¨ E2E Tests
              env:
                  # Variables d'environnement pour Docker Compose E2E
                  DB_PASSWORD_PROD: ${{ secrets.DB_PASSWORD_PROD }}
                  JWT_SECRET_PROD: ${{ secrets.JWT_SECRET_PROD }}
                  STRIPE_SECRET_KEY_PROD: ${{ secrets.STRIPE_SECRET_KEY_PROD }}
                  STRIPE_WEBHOOK_SECRET_PROD: ${{ secrets.STRIPE_WEBHOOK_SECRET_PROD }}
                  EMAIL_HOST_PROD: ${{ secrets.EMAIL_HOST_PROD }}
                  EMAIL_USER_PROD: ${{ secrets.EMAIL_USER_PROD }}
                  EMAIL_PASSWORD_PROD: ${{ secrets.EMAIL_PASSWORD_PROD }}
                  # Variables Frontend pour Docker build
                  FRONTEND_API_URL: ${{ secrets.FRONTEND_API_URL }}
                  FRONTEND_BASE_URL: ${{ secrets.FRONTEND_BASE_URL }}
                  STRIPE_PUBLISHABLE_KEY_PROD: ${{ secrets.STRIPE_PUBLISHABLE_KEY_PROD }}
                  ENABLE_ANALYTICS: ${{ secrets.ENABLE_ANALYTICS }}
                  ENABLE_HTTPS_REDIRECT: ${{ secrets.ENABLE_HTTPS_REDIRECT }}
                  SUPPORT_EMAIL: ${{ secrets.SUPPORT_EMAIL }}
                  SALES_EMAIL: ${{ secrets.SALES_EMAIL }}
                  SUPPORT_PHONE: ${{ secrets.SUPPORT_PHONE }}
                  COOKIE_DOMAIN: ${{ secrets.COOKIE_DOMAIN }}
                  COOKIE_SECURE: ${{ secrets.COOKIE_SECURE }}
                  GOOGLE_ANALYTICS_ID: ${{ secrets.GOOGLE_ANALYTICS_ID }}
                  # Variables Cypress
                  CYPRESS_BASE_URL: ${{ secrets.CYPRESS_BASE_URL_PROD }}
                  CYPRESS_API_URL: ${{ secrets.CYPRESS_API_URL_PROD }}
                  CYPRESS_ENVIRONMENT: ${{ secrets.CYPRESS_ENVIRONMENT_PROD }}
                  CYPRESS_TEST_USER_EMAIL: ${{ secrets.CYPRESS_TEST_USER_EMAIL }}
                  CYPRESS_TEST_USER_PASSWORD: ${{ secrets.CYPRESS_TEST_USER_PASSWORD }}
                  CYPRESS_TEST_ADMIN_EMAIL: ${{ secrets.CYPRESS_TEST_ADMIN_EMAIL }}
                  CYPRESS_TEST_ADMIN_PASSWORD: ${{ secrets.CYPRESS_TEST_ADMIN_PASSWORD }}
              run: |
                  echo "üöÄ Starting E2E test environment..."

                  # Nettoyer les containers existants
                  docker compose -f docker-compose.prod.yml down --remove-orphans || true
                  docker system prune -f || true

                  # V√©rifier que les ports sont libres
                  sudo lsof -ti:5432 | xargs -r sudo kill -9 || true
                  sudo lsof -ti:8080 | xargs -r sudo kill -9 || true

                  # D√©marrer PostgreSQL et frontend builder en premier
                  echo "üîç Starting PostgreSQL and frontend builder..."
                  docker compose -f docker-compose.prod.yml up postgres frontend-builder -d

                  echo "‚è≥ Waiting 60 seconds for PostgreSQL..."
                  sleep 60

                  echo "üìã PostgreSQL status:"
                  docker compose -f docker-compose.prod.yml ps postgres

                  # V√©rifier que PostgreSQL est pr√™t
                  if docker compose -f docker-compose.prod.yml exec postgres pg_isready -U assolution_user -d assolution_prod; then
                    echo "‚úÖ PostgreSQL is ready, now starting backend..."
                    
                    # D√©marrer SEULEMENT le backend pour diagnostic
                    docker compose -f docker-compose.prod.yml up backend -d
                    
                    echo "‚è≥ Waiting 2 minutes for Spring Boot backend startup..."
                    sleep 120
                    
                    echo "üìã Backend container detailed status:"
                    docker compose -f docker-compose.prod.yml ps backend
                    
                    echo "üìã Backend full logs:"
                    docker compose -f docker-compose.prod.yml logs backend
                    
                    echo "üîç Backend environment variables:"
                    docker compose -f docker-compose.prod.yml exec backend env | grep -E "(SPRING|DB|JWT|STRIPE|EMAIL)" | head -20 || echo "Cannot access backend container environment"
                    
                    echo "üîç Backend Java process:"
                    docker compose -f docker-compose.prod.yml exec backend ps aux | grep java || echo "No Java process found"
                    
                    echo "üîç Backend port check:"
                    docker compose -f docker-compose.prod.yml exec backend netstat -tulpn | grep 8080 || echo "Port 8080 not listening"
                    
                    echo "üîç Debugging backend startup script and JAR file..."
                    
                    # V√©rifier le contenu du script de d√©marrage
                    echo "üìã Backend startup script content:"
                    docker compose -f docker-compose.prod.yml exec backend cat /app/start-prod.sh || echo "Cannot read startup script"
                    
                    echo "üìã Files in /app directory:"
                    docker compose -f docker-compose.prod.yml exec backend ls -la /app/ || echo "Cannot access /app directory"
                    
                    echo "üìã JAR file details:"
                    docker compose -f docker-compose.prod.yml exec backend ls -la /app/*.jar || echo "No JAR files found"
                    
                    echo "üìã Check if JAR is executable:"
                    docker compose -f docker-compose.prod.yml exec backend file /app/app.jar || echo "Cannot check JAR file"
                    
                    echo "üìã Test JAR manually:"
                    docker compose -f docker-compose.prod.yml exec backend java -jar /app/app.jar --help || echo "JAR execution failed"

                    echo "üîç Backend health endpoint test:"
                    timeout 30 bash -c 'until curl -f http://localhost:8080/api/actuator/health; do echo "Trying backend health..."; sleep 5; done' || {
                      echo "‚ùå Backend health check failed"
                      echo "üîç Final backend container inspection:"
                      docker compose -f docker-compose.prod.yml exec backend ls -la /app/ || echo "Cannot access backend filesystem"
                      docker compose -f docker-compose.prod.yml exec backend java -version || echo "Java not accessible"
                      exit 1
                    }
                    
                    echo "‚úÖ Backend is healthy! Starting remaining services..."
                    docker compose -f docker-compose.prod.yml up -d

                    echo "üîç Checking backend start script:"
                    docker compose -f docker-compose.prod.yml exec backend cat /app/start-prod.sh || echo "Cannot read script"
                    
                  else
                    echo "‚ùå PostgreSQL failed to start"
                    docker compose -f docker-compose.prod.yml logs postgres
                    exit 1
                  fi

                  # Test final de tous les services
                  echo "‚è≥ Waiting for all services..."
                  sleep 60

                  echo "üìã Final services status:"
                  docker compose -f docker-compose.prod.yml ps

                  echo "üîç Testing all endpoints..."

                  # Test Backend
                  if curl -f http://localhost:8080/api/actuator/health; then
                    echo "‚úÖ Backend is responding"
                  else
                    echo "‚ùå Backend still not responding"
                    exit 1
                  fi

                  # Test Nginx/Frontend
                  if curl -f http://localhost:80/; then
                    echo "‚úÖ Frontend via Nginx is accessible"
                  else
                    echo "‚ùå Frontend not accessible"
                    docker compose -f docker-compose.prod.yml logs nginx --tail=20
                    exit 1
                  fi

                  echo "‚úÖ All services ready! Skipping Cypress for now to validate infrastructure"
                  # npx cypress run --spec "cypress/e2e/**/*.cy.js" --browser chrome --headless

                  # Nettoyer apr√®s les tests
                  docker compose -f docker-compose.prod.yml down

    security-scan:
        name: üîí Security Scan
        runs-on: ubuntu-latest
        needs: [test-complete]

        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: üîç Run Trivy vulnerability scanner
              uses: aquasecurity/trivy-action@master
              with:
                  scan-type: "fs"
                  scan-ref: "."
                  format: "sarif"
                  output: "trivy-results.sarif"

            - name: üì§ Upload Trivy scan results to GitHub Security tab
              uses: github/codeql-action/upload-sarif@v3
              if: always()
              with:
                  sarif_file: "trivy-results.sarif"

    deploy-prod:
        name: üöÄ Deploy to Production
        runs-on: ubuntu-latest
        needs: [test-complete, security-scan]
        environment: production

        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: üîë Setup SSH
              uses: webfactory/ssh-agent@v0.9.0
              with:
                  ssh-private-key: ${{ secrets.SSH_KEY }}

            - name: üíæ Backup Production Database
              run: |
                  ssh -o StrictHostKeyChecking=no ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "
                    cd /home/dbm/assolution-prod || exit 0
                    
                    if docker compose ps | grep postgres; then
                      timestamp=\$(date +%Y%m%d_%H%M%S)
                      mkdir -p backups
                      docker compose exec -T postgres pg_dump -U assolution_user assolution_prod > backups/backup_\${timestamp}.sql
                      echo 'üíæ Database backup created: backup_\${timestamp}.sql'
                    fi
                  "

            - name: üìÇ Deploy to Production VM
              env:
                  # ‚úÖ TOUTES les variables d'environnement pour la production
                  DB_PASSWORD_PROD: ${{ secrets.DB_PASSWORD_PROD }}
                  JWT_SECRET_PROD: ${{ secrets.JWT_SECRET_PROD }}
                  STRIPE_SECRET_KEY_PROD: ${{ secrets.STRIPE_SECRET_KEY_PROD }}
                  STRIPE_WEBHOOK_SECRET_PROD: ${{ secrets.STRIPE_WEBHOOK_SECRET_PROD }}
                  STRIPE_PUBLISHABLE_KEY_PROD: ${{ secrets.STRIPE_PUBLISHABLE_KEY_PROD }}
                  EMAIL_HOST_PROD: ${{ secrets.EMAIL_HOST_PROD }}
                  EMAIL_USER_PROD: ${{ secrets.EMAIL_USER_PROD }}
                  EMAIL_PASSWORD_PROD: ${{ secrets.EMAIL_PASSWORD_PROD }}
                  EMAIL_BASE_URL: ${{ secrets.EMAIL_BASE_URL }}
                  CORS_ALLOWED_ORIGINS: ${{ secrets.CORS_ALLOWED_ORIGINS }}
                  FRONTEND_API_URL: ${{ secrets.FRONTEND_API_URL }}
                  FRONTEND_BASE_URL: ${{ secrets.FRONTEND_BASE_URL }}
                  BACKEND_URL_PROD: ${{ secrets.BACKEND_URL_PROD }}
                  COOKIE_DOMAIN: ${{ secrets.COOKIE_DOMAIN }}
                  COOKIE_SECURE: ${{ secrets.COOKIE_SECURE }}
                  ENABLE_ANALYTICS: ${{ secrets.ENABLE_ANALYTICS }}
                  ENABLE_HTTPS_REDIRECT: ${{ secrets.ENABLE_HTTPS_REDIRECT }}
                  SUPPORT_EMAIL: ${{ secrets.SUPPORT_EMAIL }}
                  SALES_EMAIL: ${{ secrets.SALES_EMAIL }}
                  SUPPORT_PHONE: ${{ secrets.SUPPORT_PHONE }}
                  GOOGLE_ANALYTICS_ID: ${{ secrets.GOOGLE_ANALYTICS_ID }}
              run: |
                  # Cr√©er le dossier de production
                  ssh -o StrictHostKeyChecking=no ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "
                    mkdir -p /home/dbm/assolution-prod
                    sudo systemctl is-active docker || sudo systemctl start docker
                  "

                  # Copier les fichiers
                  scp -o StrictHostKeyChecking=no -r ./* ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/home/dbm/assolution-prod/

                  # D√©ploiement en production
                  ssh -o StrictHostKeyChecking=no ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "
                    cd /home/dbm/assolution-prod
                    
                    echo 'üöÄ Starting production deployment...'
                    docker compose -f docker-compose.prod.yml down --remove-orphans
                    docker compose -f docker-compose.prod.yml build --no-cache
                    docker compose -f docker-compose.prod.yml up -d
                    
                    echo '‚è≥ Waiting for services to start...'
                    sleep 60
                    
                    # Diagnostic
                    echo 'üìä Container status:'
                    docker compose -f docker-compose.prod.yml ps
                    echo 'üìã Recent logs:'
                    docker compose -f docker-compose.prod.yml logs --tail=20
                    
                    # Nettoyer les anciennes images
                    docker image prune -f
                  "

            - name: ü©∫ Production Health Checks
              run: |
                  sleep 90

                  echo "üîç Running comprehensive health checks..."

                  # Test API Health
                  for i in {1..15}; do
                    if curl -f http://${{ secrets.SSH_HOST }}/api/actuator/health; then
                      echo "‚úÖ API health check passed"
                      break
                    fi
                    echo "‚è≥ Waiting for API... (attempt $i/15)"
                    sleep 10
                    if [ $i -eq 15 ]; then
                      echo "‚ùå API health check failed after 15 attempts"
                      exit 1
                    fi
                  done

                  # Test Frontend
                  if curl -f http://${{ secrets.SSH_HOST }}/; then
                    echo "‚úÖ Frontend is accessible"
                  else
                    echo "‚ùå Frontend accessibility check failed"
                    exit 1
                  fi

            - name: üì¢ Production Deployment Notification
              if: success()
              run: |
                  echo "üéâ Production deployment successful!"
                  echo "üîó Production URL: http://${{ secrets.SSH_HOST }}"
                  echo "üîó API URL: http://${{ secrets.SSH_HOST }}/api"
                  echo "üìä Health Check: http://${{ secrets.SSH_HOST }}/api/actuator/health"

            - name: üö® Rollback on Failure
              if: failure()
              run: |
                  echo "‚ùå Deployment failed, attempting rollback..."
                  ssh -o StrictHostKeyChecking=no ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "
                    cd /home/dbm/assolution-prod
                    docker compose -f docker-compose.prod.yml down
                    docker compose -f docker-compose.prod.yml up -d
                    echo 'üîÑ Rollback completed'
                  "
                  exit 1
