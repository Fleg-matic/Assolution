name: üè≠ Deploy Production

on:
    push:
        branches: [master]
    workflow_dispatch:

jobs:
    test-complete:
        name: üß™ Complete Test Suite
        runs-on: ubuntu-latest

        services:
            postgres:
                image: postgres:17
                env:
                    POSTGRES_DB: assolution_test
                    POSTGRES_USER: assolution_user
                    POSTGRES_PASSWORD: ${{ secrets.DB_PASSWORD }}
                options: >-
                    --health-cmd pg_isready
                    --health-interval 10s
                    --health-timeout 5s
                    --health-retries 5
                ports:
                    - 5432:5432

        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: ‚òï Setup Java 21
              uses: actions/setup-java@v4
              with:
                  java-version: "21"
                  distribution: "temurin"

            - name: üü¢ Setup Node.js 22
              uses: actions/setup-node@v4
              with:
                  node-version: "22"
                  cache: "npm"
                  cache-dependency-path: ./inscriptions/inscriptions-frontend/package-lock.json

            - name: üì¶ Cache Maven dependencies
              uses: actions/cache@v4
              with:
                  path: ~/.m2
                  key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}

            - name: üîß Backend Tests & Build
              working-directory: ./inscriptions/inscriptions-backend
              run: |
                  mvn clean test verify
                  mvn jacoco:report
                  mvn package -DskipTests

            - name: üîç Generate environment.prod.ts from template
              working-directory: ./inscriptions/inscriptions-frontend
              env:
                  # ‚úÖ Variables d'environnement disponibles pour envsubst
                  FRONTEND_API_URL: ${{ secrets.FRONTEND_API_URL || '/api' }}
                  FRONTEND_BASE_URL: ${{ secrets.FRONTEND_BASE_URL || '' }}
                  STRIPE_PUBLISHABLE_KEY_PROD: ${{ secrets.STRIPE_PUBLISHABLE_KEY_PROD || 'pk_test_placeholder' }}
                  ENABLE_ANALYTICS: ${{ secrets.ENABLE_ANALYTICS || 'false' }}
                  ENABLE_HTTPS_REDIRECT: ${{ secrets.ENABLE_HTTPS_REDIRECT || 'false' }}
                  SUPPORT_EMAIL: ${{ secrets.SUPPORT_EMAIL || 'support@assolution.com' }}
                  SALES_EMAIL: ${{ secrets.SALES_EMAIL || 'contact@assolution.com' }}
                  SUPPORT_PHONE: ${{ secrets.SUPPORT_PHONE || '+33 1 XX XX XX XX' }}
                  COOKIE_DOMAIN: ${{ secrets.COOKIE_DOMAIN || 'localhost' }}
                  COOKIE_SECURE: ${{ secrets.COOKIE_SECURE || 'false' }}
                  GOOGLE_ANALYTICS_ID: ${{ secrets.GOOGLE_ANALYTICS_ID || '' }}
              run: |
                  echo "üîç Checking template existence..."
                  if [ ! -f "../../config-templates/environment.prod.ts.template" ]; then
                    echo "‚ùå Template not found!"
                    exit 1
                  fi

                  echo "üîç Debug: Environment variables:"
                  echo "FRONTEND_API_URL: $FRONTEND_API_URL"
                  echo "ENABLE_ANALYTICS: $ENABLE_ANALYTICS"
                  echo "COOKIE_SECURE: $COOKIE_SECURE"
                  echo "STRIPE_PUBLISHABLE_KEY_PROD: ${STRIPE_PUBLISHABLE_KEY_PROD:0:20}..." # Masquer la cl√©

                  echo "üîç Generating environment.prod.ts from template..."
                  mkdir -p src/environments

                  # Utiliser envsubst pour substituer les variables
                  envsubst < ../../config-templates/environment.prod.ts.template > src/environments/environment.prod.ts

                  echo "‚úÖ Environment file generated:"
                  echo "üìä File size: $(wc -l < src/environments/environment.prod.ts) lines"
                  echo "üîç First 10 lines:"
                  head -10 src/environments/environment.prod.ts

                  # V√©rification critique des substitutions
                  echo "üîç Checking TypeScript syntax..."
                  if grep -q '\${' src/environments/environment.prod.ts; then
                    echo "‚ùå Variables not properly substituted!"
                    echo "üîç Unsubstituted variables:"
                    grep -o '\${[^}]*}' src/environments/environment.prod.ts | sort | uniq
                    echo "Content preview:"
                    head -20 src/environments/environment.prod.ts
                    exit 1
                  fi

                  # V√©rification de syntaxe TypeScript
                  node -e "
                    const fs = require('fs');
                    const content = fs.readFileSync('src/environments/environment.prod.ts', 'utf8');
                    
                    // V√©rifier qu'il n'y a pas de valeurs vides probl√©matiques
                    if (content.includes(': ,') || content.includes(': undefined')) {
                      console.error('‚ùå Empty values detected!');
                      process.exit(1);
                    }
                    
                    console.log('‚úÖ File looks good');
                  "

                  echo "‚úÖ Environment.prod.ts ready for build"

            - name: üì¶ Frontend Tests & Build
              working-directory: ./inscriptions/inscriptions-frontend
              run: |
                  echo "üìß Installing Angular dependencies..."
                  npm install

                  echo "üß™ Running tests with debug..."
                  npm run test:ci -- --verbose || echo "Tests failed"

                  echo "üóÇÔ∏è Building production app..."
                  npm run build:prod

                  echo "üîç DEBUG: Checking build output structure..."
                  echo "üìÅ Contents of dist/:"
                  ls -la dist/ || echo "No dist directory"

                  echo "üìÅ Contents of dist/inscriptions-frontend/:"
                  ls -la dist/inscriptions-frontend/ || echo "No inscriptions-frontend directory"

                  echo "üìÅ Looking for browser subdirectory:"
                  ls -la dist/inscriptions-frontend/browser/ || echo "No browser subdirectory"

                  echo "üîç Searching for index.html:"
                  find dist/ -name "index.html" -type f || echo "No index.html found"

                  echo "‚úÖ Build structure analysis completed"

            - name: üìä SonarQube Analysis
              working-directory: ./inscriptions/inscriptions-backend
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                  SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
              run: |
                  mvn sonar:sonar \
                    -Dsonar.projectKey=assolution \
                    -Dsonar.organization=fleg-matic \
                    -Dsonar.host.url=https://sonarcloud.io \
                    -Dsonar.projectName="Assolution" \
                    -Dsonar.projectDescription="API REST Spring Boot pour la plateforme d'inscriptions" \
                    -Dsonar.links.homepage=https://github.com/${{ github.repository }} \
                    -Dsonar.links.ci=https://github.com/${{ github.repository }}/actions \
                    -Dsonar.links.scm=https://github.com/${{ github.repository }} \
                    -Dsonar.sources=src/main/java \
                    -Dsonar.tests=src/test/java \
                    -Dsonar.java.binaries=target/classes \
                    -Dsonar.java.test.binaries=target/test-classes \
                    -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml \
                    -Dsonar.junit.reportPaths=target/surefire-reports

            - name: üîç Debug Environment Variables
              run: |
                  echo "üîç Checking environment variables availability..."
                  echo "FRONTEND_API_URL: '${{ secrets.FRONTEND_API_URL }}'"
                  echo "FRONTEND_BASE_URL: '${{ secrets.FRONTEND_BASE_URL }}'"
                  echo "STRIPE_PUBLISHABLE_KEY_PROD: '${{ secrets.STRIPE_PUBLISHABLE_KEY_PROD }}'"
                  echo "ENABLE_ANALYTICS: '${{ secrets.ENABLE_ANALYTICS }}'"
                  echo "ENABLE_HTTPS_REDIRECT: '${{ secrets.ENABLE_HTTPS_REDIRECT }}'"
                  echo "SUPPORT_EMAIL: '${{ secrets.SUPPORT_EMAIL }}'"
                  echo "SALES_EMAIL: '${{ secrets.SALES_EMAIL }}'"
                  echo "SUPPORT_PHONE: '${{ secrets.SUPPORT_PHONE }}'"
                  echo "COOKIE_DOMAIN: '${{ secrets.COOKIE_DOMAIN }}'"
                  echo "COOKIE_SECURE: '${{ secrets.COOKIE_SECURE }}'"
                  echo "GOOGLE_ANALYTICS_ID: '${{ secrets.GOOGLE_ANALYTICS_ID }}'"

                  echo ""
                  echo "üîç Checking if variables are properly set..."
                  if [ -z "${{ secrets.FRONTEND_API_URL }}" ]; then
                    echo "‚ùå FRONTEND_API_URL is not set in GitHub secrets"
                  else
                    echo "‚úÖ FRONTEND_API_URL is set"
                  fi

                  if [ -z "${{ secrets.ENABLE_ANALYTICS }}" ]; then
                    echo "‚ùå ENABLE_ANALYTICS is not set in GitHub secrets"
                  else
                    echo "‚úÖ ENABLE_ANALYTICS is set"
                  fi

            - name: üîß Setup E2E environment and Cypress
              env:
                  # Variables pour les tests E2E
                  CYPRESS_BASE_URL: ${{ secrets.CYPRESS_BASE_URL_PROD }}
                  CYPRESS_API_URL: ${{ secrets.CYPRESS_API_URL_PROD }}
                  CYPRESS_ENVIRONMENT: ${{ secrets.CYPRESS_ENVIRONMENT_PROD }}
                  CYPRESS_TEST_USER_EMAIL: ${{ secrets.CYPRESS_TEST_USER_EMAIL }}
                  CYPRESS_TEST_USER_PASSWORD: ${{ secrets.CYPRESS_TEST_USER_PASSWORD }}
                  CYPRESS_TEST_ADMIN_EMAIL: ${{ secrets.CYPRESS_TEST_ADMIN_EMAIL }}
                  CYPRESS_TEST_ADMIN_PASSWORD: ${{ secrets.CYPRESS_TEST_ADMIN_PASSWORD }}
              run: |
                  echo "üîß Setting up Cypress environment..."

                  # Installer Cypress
                  npm install cypress --save-dev
                  npx cypress verify

                  # Utiliser le cypress.config.js existant (il g√®re d√©j√† les variables d'environnement)
                  echo "‚úÖ Cypress configured with existing config file"
                  echo "üåê Base URL: $CYPRESS_BASE_URL"
                  echo "üìå API URL: $CYPRESS_API_URL"

            - name: üîç Debug Database Variables
              env:
                  DB_PASSWORD_PROD: ${{ secrets.DB_PASSWORD_PROD }}
                  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
                  JWT_SECRET_PROD: ${{ secrets.JWT_SECRET_PROD }}
              run: |
                  echo "üîç Checking database environment variables..."

                  if [ -z "$DB_PASSWORD_PROD" ] && [ -z "$DB_PASSWORD" ]; then
                    echo "‚ùå No database password found in secrets!"
                    echo "üí° Please set either DB_PASSWORD_PROD or DB_PASSWORD in GitHub secrets"
                    exit 1
                  fi

                  if [ -n "$DB_PASSWORD_PROD" ]; then
                    echo "‚úÖ DB_PASSWORD_PROD is set (length: ${#DB_PASSWORD_PROD})"
                  fi

                  if [ -n "$DB_PASSWORD" ]; then
                    echo "‚úÖ DB_PASSWORD is set (length: ${#DB_PASSWORD})"
                  fi

                  if [ -z "$JWT_SECRET_PROD" ]; then
                    echo "‚ö†Ô∏è JWT_SECRET_PROD is not set"
                  else
                    echo "‚úÖ JWT_SECRET_PROD is set (length: ${#JWT_SECRET_PROD})"
                  fi

            - name: üî¨ E2E Tests (avec Frontend)
              env:
                  # Variables d'environnement pour Docker Compose E2E
                  DB_PASSWORD_PROD: ${{ secrets.DB_PASSWORD_PROD }}
                  JWT_SECRET_PROD: ${{ secrets.JWT_SECRET_PROD }}
                  STRIPE_SECRET_KEY_PROD: ${{ secrets.STRIPE_SECRET_KEY_PROD }}
                  STRIPE_WEBHOOK_SECRET_PROD: ${{ secrets.STRIPE_WEBHOOK_SECRET_PROD }}
                  EMAIL_HOST_PROD: ${{ secrets.EMAIL_HOST_PROD }}
                  EMAIL_USER_PROD: ${{ secrets.EMAIL_USER_PROD }}
                  EMAIL_PASSWORD_PROD: ${{ secrets.EMAIL_PASSWORD_PROD }}
                  # Variables Frontend
                  FRONTEND_API_URL: ${{ secrets.FRONTEND_API_URL }}
                  FRONTEND_BASE_URL: ${{ secrets.FRONTEND_BASE_URL }}
                  STRIPE_PUBLISHABLE_KEY_PROD: ${{ secrets.STRIPE_PUBLISHABLE_KEY_PROD }}
                  ENABLE_ANALYTICS: ${{ secrets.ENABLE_ANALYTICS }}
                  ENABLE_HTTPS_REDIRECT: ${{ secrets.ENABLE_HTTPS_REDIRECT }}
                  SUPPORT_EMAIL: ${{ secrets.SUPPORT_EMAIL }}
                  SALES_EMAIL: ${{ secrets.SALES_EMAIL }}
                  SUPPORT_PHONE: ${{ secrets.SUPPORT_PHONE }}
                  COOKIE_DOMAIN: ${{ secrets.COOKIE_DOMAIN }}
                  COOKIE_SECURE: ${{ secrets.COOKIE_SECURE }}
                  GOOGLE_ANALYTICS_ID: ${{ secrets.GOOGLE_ANALYTICS_ID }}
              run: |
                  echo "üöÄ Starting E2E test with optimized frontend..."

                  # Nettoyer les containers existants
                  docker compose -f docker-compose.prod.yml down --remove-orphans || true

                  # D√©marrer PostgreSQL
                  echo "üìä Starting PostgreSQL..."
                  docker compose -f docker-compose.prod.yml up postgres -d

                  echo "‚è≥ Waiting for PostgreSQL..."
                  sleep 60

                  if docker compose -f docker-compose.prod.yml exec postgres pg_isready -U assolution_user -d assolution_prod; then
                    echo "‚úÖ PostgreSQL is ready"
                    
                    # D√©marrer frontend-builder avec timeout
                    echo "üé® Starting optimized frontend builder..."
                    timeout 1500 docker compose -f docker-compose.prod.yml up frontend-builder || {
                      echo "‚ùå Frontend build failed or timed out"
                      echo "üìã Frontend builder logs:"
                      docker compose -f docker-compose.prod.yml logs frontend-builder
                      echo "‚ö†Ô∏è Continuing without frontend for backend testing..."
                    }
                    
                    # D√©marrer backend
                    echo "üöÄ Starting backend..."
                    docker compose -f docker-compose.prod.yml up backend -d
                    
                    echo "‚è≥ Waiting for backend..."
                    sleep 120
                    
                    # Test backend health
                    if curl -f -u admin:admin123 http://localhost:8080/actuator/health; then
                      echo "‚úÖ Backend is healthy with authentication!"
                    elif curl -f http://localhost:8080/actuator/health; then
                      echo "‚úÖ Backend is healthy without authentication!"
                    else
                      echo "‚ùå Backend health check failed"
                      docker compose -f docker-compose.prod.yml logs backend --tail=20
                      exit 1
                    fi
                    
                    # Si le frontend s'est bien construit, d√©marrer nginx
                    if docker compose -f docker-compose.prod.yml ps frontend-builder | grep -q "exited"; then
                      echo "üåê Starting Nginx..."
                      docker compose -f docker-compose.prod.yml up nginx -d
                      
                      sleep 30
                      
                      # Test frontend
                      if curl -f http://localhost:80/; then
                        echo "‚úÖ Frontend via Nginx is accessible!"
                      else
                        echo "‚ö†Ô∏è Frontend not accessible, but backend works"
                      fi
                    else
                      echo "‚ö†Ô∏è Frontend builder didn't complete, testing backend only"
                    fi
                    
                    echo "‚úÖ E2E tests completed!"
                    
                  else
                    echo "‚ùå PostgreSQL failed to start"
                    exit 1
                  fi

                  # Nettoyer
                  docker compose -f docker-compose.prod.yml down

    security-scan:
        name: üîí Security Scan
        runs-on: ubuntu-latest
        needs: [test-complete]

        permissions:
            contents: read
            security-events: write
            actions: read

        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: üîç Run Trivy vulnerability scanner
              uses: aquasecurity/trivy-action@master
              with:
                  scan-type: "fs"
                  scan-ref: "."
                  format: "sarif"
                  output: "trivy-results.sarif"

            - name: üì§ Upload Trivy scan results to GitHub Security tab
              uses: github/codeql-action/upload-sarif@v3
              if: always()
              with:
                  sarif_file: "trivy-results.sarif"

    deploy-prod:
        name: üöÄ Deploy to Production
        runs-on: self-hosted
        needs: [test-complete, security-scan]
        environment: production

        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: üîç System Info
              run: |
                  echo "üñ•Ô∏è Running on local VM:"
                  hostname
                  whoami
                  pwd
                  ip addr show | grep inet
                  docker --version

            - name: üíæ Backup Production Database
              env:
                  DB_PASSWORD_PROD: ${{ secrets.DB_PASSWORD_PROD }}
              run: |
                  cd /home/dbm/assolution-prod || {
                    echo "‚ö†Ô∏è Production directory not found, creating it..."
                    mkdir -p /home/dbm/assolution-prod
                    exit 0
                  }

                  if docker compose ps | grep postgres; then
                    timestamp=$(date +%Y%m%d_%H%M%S)
                    mkdir -p backups
                    docker compose exec -T postgres pg_dump -U assolution_user assolution_prod > backups/backup_${timestamp}.sql
                    echo "üíæ Database backup created: backup_${timestamp}.sql"
                  else
                    echo "‚ÑπÔ∏è No existing PostgreSQL container found"
                  fi

            - name: üìÇ Deploy to Local Production
              env:
                  # ‚úÖ EXPLICITEMENT TOUTES les variables d'environnement pour la production
                  DB_PASSWORD_PROD: ${{ secrets.DB_PASSWORD_PROD }}
                  JWT_SECRET_PROD: ${{ secrets.JWT_SECRET_PROD }}
                  STRIPE_SECRET_KEY_PROD: ${{ secrets.STRIPE_SECRET_KEY_PROD }}
                  STRIPE_WEBHOOK_SECRET_PROD: ${{ secrets.STRIPE_WEBHOOK_SECRET_PROD }}
                  STRIPE_PUBLISHABLE_KEY_PROD: ${{ secrets.STRIPE_PUBLISHABLE_KEY_PROD }}
                  EMAIL_HOST_PROD: ${{ secrets.EMAIL_HOST_PROD }}
                  EMAIL_USER_PROD: ${{ secrets.EMAIL_USER_PROD }}
                  EMAIL_PASSWORD_PROD: ${{ secrets.EMAIL_PASSWORD_PROD }}
                  EMAIL_BASE_URL: ${{ secrets.EMAIL_BASE_URL }}
                  CORS_ALLOWED_ORIGINS: ${{ secrets.CORS_ALLOWED_ORIGINS }}
                  FRONTEND_API_URL: ${{ secrets.FRONTEND_API_URL }}
                  FRONTEND_BASE_URL: ${{ secrets.FRONTEND_BASE_URL }}
                  BACKEND_URL_PROD: ${{ secrets.BACKEND_URL_PROD }}
                  COOKIE_DOMAIN: ${{ secrets.COOKIE_DOMAIN }}
                  COOKIE_SECURE: ${{ secrets.COOKIE_SECURE }}
                  ENABLE_ANALYTICS: ${{ secrets.ENABLE_ANALYTICS }}
                  ENABLE_HTTPS_REDIRECT: ${{ secrets.ENABLE_HTTPS_REDIRECT }}
                  SUPPORT_EMAIL: ${{ secrets.SUPPORT_EMAIL }}
                  SALES_EMAIL: ${{ secrets.SALES_EMAIL }}
                  SUPPORT_PHONE: ${{ secrets.SUPPORT_PHONE }}
                  GOOGLE_ANALYTICS_ID: ${{ secrets.GOOGLE_ANALYTICS_ID }}
                  ADMIN_PASSWORD_PROD: ${{ secrets.ADMIN_PASSWORD_PROD }}
              run: |
                  echo "üöÄ Starting local production deployment..."

                  # ‚úÖ DEBUG : V√©rifier les variables avant de commencer
                  echo "üîç Checking critical environment variables:"
                  echo "DB_PASSWORD_PROD: ${DB_PASSWORD_PROD:+SET}" 
                  echo "JWT_SECRET_PROD: ${JWT_SECRET_PROD:+SET}"
                  echo "ADMIN_PASSWORD_PROD: ${ADMIN_PASSWORD_PROD:+SET}"

                  if [ -z "$DB_PASSWORD_PROD" ]; then
                    echo "‚ùå CRITICAL: DB_PASSWORD_PROD is not set!"
                    echo "Available env vars:"
                    env | grep -E "(DB_|JWT_|ADMIN_)" || echo "No matching vars found"
                    exit 1
                  fi

                  # Cr√©er le dossier de production s'il n'existe pas
                  mkdir -p /home/dbm/assolution-prod

                  # Copier les fichiers du workspace vers le dossier de production
                  echo "üìÅ Copying files to production directory..."
                  rsync -av --exclude='.git' --exclude='node_modules' --exclude='target' \
                    ${{ github.workspace }}/ /home/dbm/assolution-prod/ || echo "Some files may not have been copied due to permissions"

                  # Changer vers le dossier de production
                  cd /home/dbm/assolution-prod

                  echo "üõë Stopping existing services..."
                  docker compose -f docker-compose.prod.yml down --remove-orphans || true

                  echo "üóÇÔ∏è Building services..."
                  docker compose -f docker-compose.prod.yml build --no-cache

                  echo "üöÄ Starting services..."
                  docker compose -f docker-compose.prod.yml up -d

                  echo "‚è≥ Waiting for services to start..."
                  sleep 60

                  # Diagnostic
                  echo "üìä Container status:"
                  docker compose -f docker-compose.prod.yml ps
                  echo "üìã Recent logs:"
                  docker compose -f docker-compose.prod.yml logs --tail=20

                  # Nettoyer les anciennes images
                  docker image prune -f

            - name: ü©∫ Production Health Checks
              env:
                  DB_PASSWORD_PROD: ${{ secrets.DB_PASSWORD_PROD }}
                  ADMIN_PASSWORD_PROD: ${{ secrets.ADMIN_PASSWORD_PROD }}
              run: |
                  sleep 30

                  echo "üîç Running comprehensive health checks..."

                  # ‚úÖ Test API Health OPTIMIS√â - tentatives plus rapides
                  for i in {1..10}; do
                    if curl -f --max-time 10 http://localhost:8080/actuator/health; then
                      echo "‚úÖ API health check passed in $i attempts"
                      break
                    fi
                    echo "‚è≥ Waiting for API... (attempt $i/10)"
                    sleep 5
                    if [ $i -eq 10 ]; then
                      echo "‚ùå API health check failed after 10 attempts"
                      echo "üìã Backend logs:"
                      cd /home/dbm/assolution-prod
                      docker compose -f docker-compose.prod.yml logs backend --tail=50
                      echo "üìä Container status:"
                      docker compose -f docker-compose.prod.yml ps
                      echo "üîç System resources:"
                      docker stats --no-stream
                      exit 1
                    fi
                  done

                  # ‚úÖ Test plus d√©taill√© de l'API avec timeout
                  echo "üîç Testing API endpoints..."

                  # Test health avec d√©tails et timeout
                  health_response=$(curl -s --max-time 5 http://localhost:8080/actuator/health)
                  echo "üìä Health response: $health_response"

                  # V√©rifier que la r√©ponse contient "UP"
                  if echo "$health_response" | grep -q '"status":"UP"'; then
                    echo "‚úÖ API status is UP"
                    
                    # Test des m√©triques si disponibles
                    if curl -f --max-time 5 http://localhost:8080/actuator/info >/dev/null 2>&1; then
                      echo "‚úÖ API info endpoint accessible"
                    fi
                  else
                    echo "‚ùå API status is not UP"
                    echo "üìã Full health response: $health_response"
                    exit 1
                  fi

                  # Test Frontend
                  if curl -f http://localhost:80/; then
                    echo "‚úÖ Frontend is accessible"
                  elif curl -f http://localhost:4200/; then
                    echo "‚úÖ Frontend is accessible on port 4200"
                  else
                    echo "‚ùå Frontend accessibility check failed"
                    echo "üìã Frontend/Nginx logs:"
                    cd /home/dbm/assolution-prod
                    docker compose -f docker-compose.prod.yml logs nginx --tail=20
                    exit 1
                  fi

            - name: üì¢ Production Deployment Notification
              if: success()
              run: |
                  echo "üéâ Production deployment successful!"
                  echo "üîó Production URL: http://192.168.1.22"
                  echo "üîó API URL: http://192.168.1.22/api"
                  echo "üìä Health Check: http://192.168.1.22/api/actuator/health"

                  # Afficher les informations syst√®me
                  echo "üñ•Ô∏è System Resources:"
                  df -h /
                  free -h
                  docker system df

            - name: üö® Rollback on Failure
              if: failure()
              env:
                  DB_PASSWORD_PROD: ${{ secrets.DB_PASSWORD_PROD }}
              run: |
                  echo "‚ùå Deployment failed, attempting rollback..."
                  cd /home/dbm/assolution-prod

                  # Sauvegarder les logs de l'√©chec
                  timestamp=$(date +%Y%m%d_%H%M%S)
                  mkdir -p logs
                  docker compose -f docker-compose.prod.yml logs > logs/failed_deployment_${timestamp}.log

                  # Red√©marrer les services
                  docker compose -f docker-compose.prod.yml down
                  docker compose -f docker-compose.prod.yml up -d
                  echo "üîÑ Rollback completed"

                  # V√©rifier que le rollback fonctionne
                  sleep 30
                  if curl -f http://localhost:80/ || curl -f http://localhost:4200/; then
                    echo "‚úÖ Rollback successful - application is running"
                  else
                    echo "‚ùå Rollback failed - manual intervention required"
                  fi

                  exit 1
