name: 🏭 Deploy Production

on:
    push:
        branches: [master]
    workflow_dispatch:

jobs:
    test-complete:
        name: 🧪 Complete Test Suite
        runs-on: ubuntu-latest

        services:
            postgres:
                image: postgres:17
                env:
                    POSTGRES_DB: assolution_test
                    POSTGRES_USER: assolution_user
                    POSTGRES_PASSWORD: ${{ secrets.DB_PASSWORD }}
                options: >-
                    --health-cmd pg_isready
                    --health-interval 10s
                    --health-timeout 5s
                    --health-retries 5
                ports:
                    - 5432:5432

        steps:
            - name: 📥 Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: ☕ Setup Java 21
              uses: actions/setup-java@v4
              with:
                  java-version: "21"
                  distribution: "temurin"

            - name: 🟢 Setup Node.js 22
              uses: actions/setup-node@v4
              with:
                  node-version: "22"
                  cache: "npm"
                  cache-dependency-path: ./inscriptions/inscriptions-frontend/package-lock.json

            - name: 📦 Cache Maven dependencies
              uses: actions/cache@v4
              with:
                  path: ~/.m2
                  key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}

            - name: 🔧 Backend Tests & Build
              working-directory: ./inscriptions/inscriptions-backend
              run: |
                  mvn clean test verify
                  mvn jacoco:report
                  mvn package -DskipTests

            - name: 📦 Frontend Tests & Build
              working-directory: ./inscriptions/inscriptions-frontend
              run: |
                  npm cache clean --force
                  rm -f package-lock.json
                  npm install
                  npm run test:ci
                  npm run build:prod

            - name: 📊 SonarQube Analysis
              working-directory: ./inscriptions/inscriptions-backend
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                  SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
              run: |
                  mvn sonar:sonar \
                    -Dsonar.projectKey=assolution \
                    -Dsonar.organization=fleg-matic \
                    -Dsonar.host.url=https://sonarcloud.io \
                    -Dsonar.projectName="Assolution" \
                    -Dsonar.projectDescription="API REST Spring Boot pour la plateforme d'inscriptions" \
                    -Dsonar.links.homepage=https://github.com/${{ github.repository }} \
                    -Dsonar.links.ci=https://github.com/${{ github.repository }}/actions \
                    -Dsonar.links.scm=https://github.com/${{ github.repository }} \
                    -Dsonar.sources=src/main/java \
                    -Dsonar.tests=src/test/java \
                    -Dsonar.java.binaries=target/classes \
                    -Dsonar.java.test.binaries=target/test-classes \
                    -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml \
                    -Dsonar.junit.reportPaths=target/surefire-reports

            - name: 🔧 Generate config files for E2E
              run: |
                  echo "📝 Création du fichier cypress.config.js..."
                  cat > cypress.config.js << 'EOF'
                  const { defineConfig } = require('cypress')

                  module.exports = defineConfig({
                    e2e: {
                      baseUrl: '${{ secrets.CYPRESS_BASE_URL }}',
                      apiUrl: '${{ secrets.CYPRESS_API_URL }}',
                      env: {
                        environment: '${{ secrets.CYPRESS_ENVIRONMENT }}',
                        testUserEmail: '${{ secrets.CYPRESS_TEST_USER_EMAIL }}',
                        testUserPassword: '${{ secrets.CYPRESS_TEST_USER_PASSWORD }}',
                        testAdminEmail: '${{ secrets.CYPRESS_TEST_ADMIN_EMAIL }}',
                        testAdminPassword: '${{ secrets.CYPRESS_TEST_ADMIN_PASSWORD }}'
                      },
                      setupNodeEvents(on, config) {
                        // implement node event listeners here
                      },
                    },
                  })
                  EOF

                  echo "📝 Création du fichier docker-compose.prod.yml..."
                  cat > docker-compose.prod.yml << 'EOF'
                  version: '3.8'
                  services:
                    postgres:
                      image: postgres:17
                      environment:
                        POSTGRES_DB: assolution_prod
                        POSTGRES_USER: assolution_user
                        POSTGRES_PASSWORD: ${{ secrets.DB_PASSWORD }}
                      volumes:
                        - postgres_data:/var/lib/postgresql/data
                      healthcheck:
                        test: ["CMD-SHELL", "pg_isready -U assolution_user -d assolution_prod"]
                        interval: 10s
                        timeout: 5s
                        retries: 5
                      ports:
                        - "5434:5432"
                      networks:
                        - assolution-prod-network
                    
                    backend:
                      build:
                        context: ./inscriptions/inscriptions-backend
                        dockerfile: Dockerfile.prod
                      environment:
                        SPRING_PROFILES_ACTIVE: prod
                        SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/assolution_prod
                        SPRING_DATASOURCE_USERNAME: assolution_user
                        SPRING_DATASOURCE_PASSWORD: ${{ secrets.DB_PASSWORD }}
                        JWT_SECRET: ${{ secrets.JWT_SECRET }}
                        STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
                        EMAIL_HOST: ${{ secrets.EMAIL_HOST }}
                        EMAIL_USER: ${{ secrets.EMAIL_USER }}
                        EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
                      depends_on:
                        postgres:
                          condition: service_healthy
                      networks:
                        - assolution-prod-network
                      healthcheck:
                        test: ["CMD-SHELL", "curl -f http://localhost:8080/api/health || exit 1"]
                        interval: 30s
                        timeout: 10s
                        retries: 5
                        start_period: 60s
                    
                    frontend:
                      build:
                        context: ./inscriptions/inscriptions-frontend
                        dockerfile: Dockerfile.prod
                      networks:
                        - assolution-prod-network
                      healthcheck:
                        test: ["CMD-SHELL", "curl -f http://localhost:4200 || exit 1"]
                        interval: 30s
                        timeout: 10s
                        retries: 3
                        start_period: 30s
                    
                    nginx:
                      image: nginx:1.25-alpine
                      ports:
                        - "80:80"
                      volumes:
                        - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
                      depends_on:
                        frontend:
                          condition: service_healthy
                        backend:
                          condition: service_healthy
                      networks:
                        - assolution-prod-network
                      healthcheck:
                        test: ["CMD", "curl", "-f", "http://localhost/nginx-health"]
                        interval: 30s
                        timeout: 10s
                        retries: 3

                  networks:
                    assolution-prod-network:
                      driver: bridge

                  volumes:
                    postgres_data:
                  EOF

                  echo "📝 Création du fichier application-prod.properties..."
                  cat > inscriptions/inscriptions-backend/src/main/resources/application-prod.properties << 'EOF'
                  # Server Configuration
                  server.port=8080
                  server.servlet.context-path=/api

                  # Database Configuration
                  spring.datasource.url=jdbc:postgresql://postgres:5432/assolution_prod
                  spring.datasource.username=assolution_user
                  spring.datasource.password=${{ secrets.DB_PASSWORD }}
                  spring.datasource.driver-class-name=org.postgresql.Driver

                  # JPA Configuration
                  spring.jpa.hibernate.ddl-auto=validate
                  spring.jpa.show-sql=false
                  spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
                  spring.jpa.properties.hibernate.format_sql=false

                  # JWT Configuration
                  app.jwt.secret=${{ secrets.JWT_SECRET }}
                  app.jwt.expiration=86400

                  # Stripe Configuration
                  stripe.secret.key=${{ secrets.STRIPE_SECRET_KEY }}
                  stripe.webhook.secret=${{ secrets.STRIPE_WEBHOOK_SECRET }}

                  # Email Configuration
                  spring.mail.host=${{ secrets.EMAIL_HOST }}
                  spring.mail.port=587
                  spring.mail.username=${{ secrets.EMAIL_USER }}
                  spring.mail.password=${{ secrets.EMAIL_PASSWORD }}
                  spring.mail.properties.mail.smtp.auth=true
                  spring.mail.properties.mail.smtp.starttls.enable=true

                  # Logging Configuration
                  logging.level.com.assolution=WARN
                  logging.level.org.springframework.security=WARN
                  logging.level.org.hibernate=WARN
                  EOF

            - name: 🔬 E2E Tests
              run: |
                  # Installer Cypress
                  npm install cypress --save-dev
                  npx cypress verify

                  # Nettoyer les containers existants
                  docker compose -f docker-compose.prod.yml down --remove-orphans || true
                  docker system prune -f || true

                  # Vérifier que le port 5432 est libre
                  sudo lsof -ti:5432 | xargs -r sudo kill -9 || true

                  # Démarrer les services en arrière-plan
                  docker compose -f docker-compose.prod.yml up -d

                  # Attendre que les services soient prêts (plus de temps pour la prod)
                  echo "⏳ Waiting for services to be ready..."
                  sleep 60

                  # Vérifier les logs pour diagnostic
                  echo "📋 Checking container status..."
                  docker compose -f docker-compose.prod.yml ps

                  echo "📋 Backend logs:"
                  docker compose -f docker-compose.prod.yml logs backend --tail=20

                  echo "📋 Nginx logs:"
                  docker compose -f docker-compose.prod.yml logs nginx --tail=10

                  # Test de connectivité progressif
                  echo "🔍 Testing backend health directly..."
                  timeout 120 bash -c 'until curl -f http://localhost:8080/api/health; do echo "Waiting for backend..."; sleep 5; done' || echo "Backend direct test failed"

                  echo "🔍 Testing nginx health..."
                  timeout 180 bash -c 'until curl -f http://localhost:80/nginx-health; do echo "Waiting for nginx..."; sleep 5; done'

                  # Lancer les tests Cypress
                  npx cypress run --config-file ./cypress.config.js --spec "./cypress/e2e/**/*.cy.js" --browser chrome --headless

                  # Nettoyer
                  docker compose -f docker-compose.prod.yml down

    security-scan:
        name: 🔒 Security Scan
        runs-on: ubuntu-latest
        needs: [test-complete]

        steps:
            - name: 📥 Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: 🔍 Run Trivy vulnerability scanner
              uses: aquasecurity/trivy-action@master
              with:
                  scan-type: "fs"
                  scan-ref: "."
                  format: "sarif"
                  output: "trivy-results.sarif"

            - name: 📤 Upload Trivy scan results to GitHub Security tab
              uses: github/codeql-action/upload-sarif@v3
              if: always()
              with:
                  sarif_file: "trivy-results.sarif"

    deploy-prod:
        name: 🚀 Deploy to Production
        runs-on: ubuntu-latest
        needs: [test-complete, security-scan]
        environment: production

        steps:
            - name: 📥 Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: 🔧 Generate production config files
              run: |
                  echo "📝 Création du fichier environment.prod.ts..."
                  cat > inscriptions/inscriptions-frontend/src/environments/environment.prod.ts << 'EOF'
                  export const environment = {
                    production: true,
                    apiUrl: '${{ secrets.FRONTEND_API_URL }}',
                    baseUrl: '${{ secrets.FRONTEND_BASE_URL }}',
                    stripePublishableKey: '${{ secrets.STRIPE_PUBLISHABLE_KEY_PROD }}',
                    enableHttpsRedirect: ${{ secrets.ENABLE_HTTPS_REDIRECT }},
                    
                    // Contact Information
                    supportEmail: '${{ secrets.SUPPORT_EMAIL }}',
                    salesEmail: '${{ secrets.SALES_EMAIL }}',
                    supportPhone: '${{ secrets.SUPPORT_PHONE }}',
                    
                    // Cookie Configuration
                    cookieDomain: '${{ secrets.COOKIE_DOMAIN }}',
                    cookieSecure: ${{ secrets.COOKIE_SECURE }},
                    
                    // Analytics
                    googleAnalyticsId: '${{ secrets.GOOGLE_ANALYTICS_ID }}',
                    enableAnalytics: ${{ secrets.ENABLE_ANALYTICS }}
                  };
                  EOF

                  echo "✅ Fichiers de production créés !"

            - name: 🔑 Setup SSH
              uses: webfactory/ssh-agent@v0.9.0
              with:
                  ssh-private-key: ${{ secrets.SSH_KEY }}

            - name: 💾 Backup Production Database
              run: |
                  ssh -o StrictHostKeyChecking=no ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "
                    cd /home/dbm/assolution-prod || exit 0
                    
                    # Créer un backup avant déploiement
                    if docker compose ps | grep postgres; then
                      timestamp=\$(date +%Y%m%d_%H%M%S)
                      mkdir -p backups
                      docker compose exec -T postgres pg_dump -U assolution_user assolution_prod > backups/backup_\${timestamp}.sql
                      echo '💾 Database backup created: backup_\${timestamp}.sql'
                    fi
                  "

            - name: 📂 Deploy to Production VM
              run: |
                  # Créer le dossier de production
                  ssh -o StrictHostKeyChecking=no ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "
                    mkdir -p /home/dbm/assolution-prod
                    sudo systemctl is-active docker || sudo systemctl start docker
                  "

                  # Copier les fichiers
                  scp -o StrictHostKeyChecking=no -r ./* ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/home/dbm/assolution-prod/

                  # Déploiement en production
                  ssh -o StrictHostKeyChecking=no ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "
                    cd /home/dbm/assolution-prod
                    
                    # Rolling update : démarrer les nouveaux containers
                    docker compose -f docker-compose.prod.yml up -d --build --no-deps backend
                    sleep 30
                    
                    # Vérifier que le backend est opérationnel
                    if curl -f http://localhost/api/health; then
                      echo '✅ Backend is healthy, updating frontend'
                      docker compose -f docker-compose.prod.yml up -d --build --no-deps frontend nginx
                    else
                      echo '❌ Backend health check failed, rolling back'
                      exit 1
                    fi
                    
                    # Nettoyer les anciennes images
                    docker image prune -f
                    
                    # Logs
                    docker compose -f docker-compose.prod.yml ps
                    docker compose -f docker-compose.prod.yml logs --tail=20
                  "

            - name: 🩺 Production Health Checks
              run: |
                  sleep 90

                  # Tests de santé complets
                  echo "🔍 Running comprehensive health checks..."

                  # Test API Health
                  for i in {1..15}; do
                    if curl -f http://${{ secrets.SSH_HOST }}/api/health; then
                      echo "✅ API health check passed"
                      break
                    fi
                    echo "⏳ Waiting for API... (attempt $i/15)"
                    sleep 10
                    if [ $i -eq 15 ]; then
                      echo "❌ API health check failed after 15 attempts"
                      exit 1
                    fi
                  done

                  # Test Frontend
                  if curl -f http://${{ secrets.SSH_HOST }}/; then
                    echo "✅ Frontend is accessible"
                  else
                    echo "❌ Frontend accessibility check failed"
                    exit 1
                  fi

                  # Test Database Connection
                  if curl -f http://${{ secrets.SSH_HOST }}/api/health/db; then
                    echo "✅ Database connection is healthy"
                  else
                    echo "❌ Database connection check failed"
                    exit 1
                  fi

            - name: 🔄 Post-Deployment Tasks
              run: |
                  ssh -o StrictHostKeyChecking=no ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "
                    cd /home/dbm/assolution-prod
                    
                    # Logs de déploiement
                    echo '📊 === DEPLOYMENT REPORT ===' > deployment_report.txt
                    echo 'Deployment Date: \$(date)' >> deployment_report.txt
                    echo 'Git Commit: ${{ github.sha }}' >> deployment_report.txt
                    echo 'Deployed by: ${{ github.actor }}' >> deployment_report.txt
                    echo '' >> deployment_report.txt
                    echo '🐳 Container Status:' >> deployment_report.txt
                    docker compose -f docker-compose.prod.yml ps >> deployment_report.txt
                    
                    # Garder seulement les 10 derniers backups
                    find backups/ -name '*.sql' -type f -print0 | xargs -0 ls -t | tail -n +11 | xargs -I {} rm -- {} || true
                  "

            - name: 📢 Production Deployment Notification
              if: success()
              run: |
                  echo "🎉 Production deployment successful!"
                  echo "🔗 Production URL: http://${{ secrets.SSH_HOST }}"
                  echo "🔗 API URL: http://${{ secrets.SSH_HOST }}/api"
                  echo "📊 Health Check: http://${{ secrets.SSH_HOST }}/api/health"
                  echo "🔒 Security scan completed"
                  echo "💾 Database backup created"

            - name: 🚨 Rollback on Failure
              if: failure()
              run: |
                  echo "❌ Deployment failed, attempting rollback..."
                  ssh -o StrictHostKeyChecking=no ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "
                    cd /home/dbm/assolution-prod
                    
                    # Utiliser la dernière image qui fonctionnait
                    docker compose -f docker-compose.prod.yml down
                    docker compose -f docker-compose.prod.yml up -d
                    
                    echo '🔄 Rollback completed'
                  "
                  exit 1
