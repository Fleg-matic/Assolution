deploy-prod:
    name: üöÄ Deploy to Production
    runs-on: self-hosted
    needs: [test-complete, security-scan]
    environment: production

    steps:
        - name: üì• Checkout code
          uses: actions/checkout@v4
          with:
              fetch-depth: 0

        - name: üß™ Test Environment Variables DEBUG
              env:
                DB_PASSWORD_PROD: ${{ secrets.DB_PASSWORD_PROD }}
                JWT_SECRET_PROD: ${{ secrets.JWT_SECRET_PROD }}
                ADMIN_PASSWORD_PROD: ${{ secrets.ADMIN_PASSWORD_PROD }}
                EMAIL_HOST_PROD: ${{ secrets.EMAIL_HOST_PROD }}
              run: |
                echo "üîç Testing environment variables:"
                echo "DB_PASSWORD_PROD: ${DB_PASSWORD_PROD:+PRESENT ($(echo $DB_PASSWORD_PROD | wc -c) chars)}"
                echo "JWT_SECRET_PROD: ${JWT_SECRET_PROD:+PRESENT}"
                echo "ADMIN_PASSWORD_PROD: ${ADMIN_PASSWORD_PROD:+PRESENT}"
                echo "EMAIL_HOST_PROD: ${EMAIL_HOST_PROD:+PRESENT}"
                
                echo ""
                echo "üîç Complete environment check:"
                echo "Total environment variables: $(env | wc -l)"
                echo "GitHub-related vars:"
                env | grep -E "^(GITHUB_|RUNNER_)" | head -5
                
                echo ""
                if [ -z "$DB_PASSWORD_PROD" ]; then
                  echo "‚ùå DB_PASSWORD_PROD is empty!"
                  echo "Available secrets starting with DB_:"
                  env | grep "DB_" || echo "No DB_ vars found"
                  echo "Available secrets:"
                  env | grep -E "(SECRET|PASSWORD|TOKEN)" | cut -d= -f1 | head -10
                  exit 1
                else
                  echo "‚úÖ DB_PASSWORD_PROD is properly set with $(echo $DB_PASSWORD_PROD | wc -c) characters"
                fi

        - name: üîç System Info
          run: |
              echo "üñ•Ô∏è Running on local VM:"
              hostname
              whoami
              pwd
              ip addr show | grep inet
              docker --version

        - name: üíæ Backup Production Database
          env:
              DB_PASSWORD_PROD: ${{ secrets.DB_PASSWORD_PROD }}
          run: |
              cd /home/dbm/assolution-prod || {
                echo "‚ö†Ô∏è Production directory not found, creating it..."
                mkdir -p /home/dbm/assolution-prod
                exit 0
              }

              if docker compose ps | grep postgres; then
                timestamp=$(date +%Y%m%d_%H%M%S)
                mkdir -p backups
                docker compose exec -T postgres pg_dump -U assolution_user assolution_prod > backups/backup_${timestamp}.sql
                echo "üíæ Database backup created: backup_${timestamp}.sql"
              else
                echo "‚ÑπÔ∏è No existing PostgreSQL container found"
              fi

        - name: üìÇ Deploy to Local Production
          env:
              # ‚úÖ EXPLICITEMENT TOUTES les variables d'environnement pour la production
              DB_PASSWORD_PROD: ${{ secrets.DB_PASSWORD_PROD }}
              JWT_SECRET_PROD: ${{ secrets.JWT_SECRET_PROD }}
              STRIPE_SECRET_KEY_PROD: ${{ secrets.STRIPE_SECRET_KEY_PROD }}
              STRIPE_WEBHOOK_SECRET_PROD: ${{ secrets.STRIPE_WEBHOOK_SECRET_PROD }}
              STRIPE_PUBLISHABLE_KEY_PROD: ${{ secrets.STRIPE_PUBLISHABLE_KEY_PROD }}
              EMAIL_HOST_PROD: ${{ secrets.EMAIL_HOST_PROD }}
              EMAIL_USER_PROD: ${{ secrets.EMAIL_USER_PROD }}
              EMAIL_PASSWORD_PROD: ${{ secrets.EMAIL_PASSWORD_PROD }}
              EMAIL_BASE_URL: ${{ secrets.EMAIL_BASE_URL }}
              CORS_ALLOWED_ORIGINS: ${{ secrets.CORS_ALLOWED_ORIGINS }}
              FRONTEND_API_URL: ${{ secrets.FRONTEND_API_URL }}
              FRONTEND_BASE_URL: ${{ secrets.FRONTEND_BASE_URL }}
              BACKEND_URL_PROD: ${{ secrets.BACKEND_URL_PROD }}
              COOKIE_DOMAIN: ${{ secrets.COOKIE_DOMAIN }}
              COOKIE_SECURE: ${{ secrets.COOKIE_SECURE }}
              ENABLE_ANALYTICS: ${{ secrets.ENABLE_ANALYTICS }}
              ENABLE_HTTPS_REDIRECT: ${{ secrets.ENABLE_HTTPS_REDIRECT }}
              SUPPORT_EMAIL: ${{ secrets.SUPPORT_EMAIL }}
              SALES_EMAIL: ${{ secrets.SALES_EMAIL }}
              SUPPORT_PHONE: ${{ secrets.SUPPORT_PHONE }}
              GOOGLE_ANALYTICS_ID: ${{ secrets.GOOGLE_ANALYTICS_ID }}
              ADMIN_PASSWORD_PROD: ${{ secrets.ADMIN_PASSWORD_PROD }}
          run: |
              echo "üöÄ Starting local production deployment..."

              # ‚úÖ DEBUG : V√©rifier les variables avant de commencer
              echo "üîç Checking critical environment variables:"
              echo "DB_PASSWORD_PROD: ${DB_PASSWORD_PROD:+SET}" 
              echo "JWT_SECRET_PROD: ${JWT_SECRET_PROD:+SET}"
              echo "ADMIN_PASSWORD_PROD: ${ADMIN_PASSWORD_PROD:+SET}"

              if [ -z "$DB_PASSWORD_PROD" ]; then
                echo "‚ùå CRITICAL: DB_PASSWORD_PROD is not set!"
                echo "Available env vars:"
                env | grep -E "(DB_|JWT_|ADMIN_)" || echo "No matching vars found"
                exit 1
              fi

              # Cr√©er le dossier de production s'il n'existe pas
              mkdir -p /home/dbm/assolution-prod

              # Copier les fichiers du workspace vers le dossier de production
              echo "üìÅ Copying files to production directory..."
              rsync -av --exclude='.git' --exclude='node_modules' --exclude='target' \
                ${{ github.workspace }}/ /home/dbm/assolution-prod/

              # Changer vers le dossier de production
              cd /home/dbm/assolution-prod

              echo "üõë Stopping existing services..."
              docker compose -f docker-compose.prod.yml down --remove-orphans || true

              echo "üóÇÔ∏è Building services..."
              docker compose -f docker-compose.prod.yml build --no-cache

              echo "üöÄ Starting services..."
              docker compose -f docker-compose.prod.yml up -d

              echo "‚è≥ Waiting for services to start..."
              sleep 60

              # Diagnostic
              echo "üìä Container status:"
              docker compose -f docker-compose.prod.yml ps
              echo "üìã Recent logs:"
              docker compose -f docker-compose.prod.yml logs --tail=20

              # Nettoyer les anciennes images
              docker image prune -f

        - name: ü©∫ Production Health Checks
          env:
              DB_PASSWORD_PROD: ${{ secrets.DB_PASSWORD_PROD }}
              ADMIN_PASSWORD_PROD: ${{ secrets.ADMIN_PASSWORD_PROD }}
          run: |
              sleep 30

              echo "üîç Running comprehensive health checks..."

              # ‚úÖ Test API Health OPTIMIS√â - tentatives plus rapides
              for i in {1..10}; do
                if curl -f --max-time 10 http://localhost:8080/actuator/health; then
                  echo "‚úÖ API health check passed in $i attempts"
                  break
                fi
                echo "‚è≥ Waiting for API... (attempt $i/10)"
                sleep 5
                if [ $i -eq 10 ]; then
                  echo "‚ùå API health check failed after 10 attempts"
                  echo "üìã Backend logs:"
                  cd /home/dbm/assolution-prod
                  docker compose -f docker-compose.prod.yml logs backend --tail=50
                  echo "üìä Container status:"
                  docker compose -f docker-compose.prod.yml ps
                  echo "üîç System resources:"
                  docker stats --no-stream
                  exit 1
                fi
              done

              # ‚úÖ Test plus d√©taill√© de l'API avec timeout
              echo "üîç Testing API endpoints..."

              # Test health avec d√©tails et timeout
              health_response=$(curl -s --max-time 5 http://localhost:8080/actuator/health)
              echo "üìä Health response: $health_response"

              # V√©rifier que la r√©ponse contient "UP"
              if echo "$health_response" | grep -q '"status":"UP"'; then
                echo "‚úÖ API status is UP"
                
                # Test des m√©triques si disponibles
                if curl -f --max-time 5 http://localhost:8080/actuator/info >/dev/null 2>&1; then
                  echo "‚úÖ API info endpoint accessible"
                fi
              else
                echo "‚ùå API status is not UP"
                echo "üìã Full health response: $health_response"
                exit 1
              fi

              # Test Frontend
              if curl -f http://localhost:80/; then
                echo "‚úÖ Frontend is accessible"
              elif curl -f http://localhost:4200/; then
                echo "‚úÖ Frontend is accessible on port 4200"
              else
                echo "‚ùå Frontend accessibility check failed"
                echo "üìã Frontend/Nginx logs:"
                cd /home/dbm/assolution-prod
                docker compose -f docker-compose.prod.yml logs nginx --tail=20
                exit 1
              fi

        - name: üì¢ Production Deployment Notification
          if: success()
          run: |
              echo "üéâ Production deployment successful!"
              echo "üîó Production URL: http://192.168.1.22"
              echo "üîó API URL: http://192.168.1.22/api"
              echo "üìä Health Check: http://192.168.1.22/api/actuator/health"

              # Afficher les informations syst√®me
              echo "üñ•Ô∏è System Resources:"
              df -h /
              free -h
              docker system df

        - name: üö® Rollback on Failure
          if: failure()
          env:
              DB_PASSWORD_PROD: ${{ secrets.DB_PASSWORD_PROD }}
          run: |
              echo "‚ùå Deployment failed, attempting rollback..."
              cd /home/dbm/assolution-prod

              # Sauvegarder les logs de l'√©chec
              timestamp=$(date +%Y%m%d_%H%M%S)
              mkdir -p logs
              docker compose -f docker-compose.prod.yml logs > logs/failed_deployment_${timestamp}.log

              # Red√©marrer les services
              docker compose -f docker-compose.prod.yml down
              docker compose -f docker-compose.prod.yml up -d
              echo "üîÑ Rollback completed"

              # V√©rifier que le rollback fonctionne
              sleep 30
              if curl -f http://localhost:80/ || curl -f http://localhost:4200/; then
                echo "‚úÖ Rollback successful - application is running"
              else
                echo "‚ùå Rollback failed - manual intervention required"
              fi

              exit 1
